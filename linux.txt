#
    BASICCOMMANDS

pwd

echo "Hello!" or echo Hello!

uptime

history             // To know history of commands that have been ran

#

    HELP SYSTEM IN Linux

                    // To know a short summary of what a command does.
    
whatis ls
ls (1)               - list directory contents

                    // To get help content of a command on screen

ls --help

                    // To open the man pages of commands

man ls

man echo            // use man command to know more about any command.

#

apropos man         // Each manual page has a short description available within it.  apropos searches the descriptions for instances of keyword.

#

    TYPE OF Commands

    ================================================================================================================
    Type	                Description
    Internal Commands	    Built into the shell (e.g. Bash), no separate executable file. Fast, always available.
    External Commands	    Stored as separate binaries (usually in /bin, /usr/bin). Run by calling the binary.

    Linux Internal vs External Commands ‚Äì Table
    --------------------------------------------
    Command	        Type	        Description	                    How to Check
    cd	            Internal	    Change directory	            type cd ‚Üí cd is a shell builtin
    echo	        Internal	    Print to terminal	            type echo
    pwd	            Internal	    Show current directory	        type pwd
    exit	        Internal	    Exit shell session	            type exit
    export	        Internal	    Set environment variable	    type export
    alias	        Internal	    Create command shortcuts	    type alias
    read	        Internal	    Read user input	                type read
    set	            Internal	    Set shell variables / options	type set
    umask	        Internal	    Set default permission mask	    type umask
    history	        Internal	    Show command history	        type history

    Command	        Type	        Description	                    Where It's Stored
    ls	            External	    List directory contents	        /bin/ls
    cp	            External	    Copy files/directories	        /bin/cp
    mv	            External	    Move/rename files	            /bin/mv
    rm	            External	    Remove files	                /bin/rm
    mkdir	        External	    Create directory	            /bin/mkdir
    ping	        External	    Send ICMP packets	            /bin/ping or /usr/bin/ping
    top	            External	    Show processes/resources	    /usr/bin/top
    ps	            External	    Process snapshot	            /bin/ps
    netstat	        External	    Show network connections	    /usr/bin/netstat
    find	        External	    Find files	                    /usr/bin/find
    grep	        External	    Search inside files	            /bin/grep
    df	            External	    Show disk space	                /bin/df
    tar	            External	    Archive files	                /bin/tar
    curl	        External	    Transfer data over network	    /usr/bin/curl
    systemctl	    External	    Manage system services (systemd)/bin/systemctl
    ================================================================================================================

#

    type echo #use type command to know whether a command is internal or External.

#

    mkdir directory     // To create a directory

mkdir -p directory1/{directory2,directory3} #To have folder structure as directory1/directory2 and directory1/directory3

#

    touch file          // To create a file

touch directory1/directory2/file.txt          // creates a file with name file.txt

#

    To view the folder structure of any directory

tree

ls -R

#

                        // Scroll and search within the file

        more

        [Space] - scrolls the display, one screensful of data at a time.
        [Enter] - scrolls the display one line.
        [b] - scrolls the display backwards one screenful of data.
        [/] - search text

more file.txt

        less
        [Up Arrow] - scrolls up the display one line.
        [Down Arrow] - scrolls down the display one line.
        [/] - search text

less file.txt

#

    SHELLS : A shell is a command-line interpreter. It takes the commands you type and passes them to the Linux kernel to execute.

    Main Types of Shells
    Shell	                            Path (usually)	        Description
    Bourne Shell (sh)	                /bin/sh	                The original Unix shell; basic and fast
    Bash (Bourne Again Shell)	        /bin/bash	            Most popular; default on many systems
    Zsh (Z Shell)	                    /bin/zsh	            Advanced features, customization, oh-my-zsh themes
    Korn Shell (ksh)	                /bin/ksh	            Combines features of sh and csh; used in enterprises
    C Shell (csh)	                    /bin/csh	            C-like syntax, mostly historical
    Fish (Friendly Interactive Shell)	/usr/bin/fish	        Modern, user-friendly with syntax highlighting


echo $SHELL                 // To know which shell is in use

chsh                        // To change the shell

alias dt=date               // Setting an alias for dat command

#

    ENVIRONMENT VARIABLES

env                         // To display all variables in the shell environment.

echo $SHELL                 // To display value stored in a single variable.
echo $LOGNAME

export OFFICE=Caleston      // To set value of a variable.
OFFICE=Caleston             // Variable value set only for the current session.

    ~/.profile
    or
    ~/.pam_environment      // To make the values of variables permanent over reboots, set them in the user profile.

#

    PATH VARIABLE
    When a user issues an external command into the shell, the shell uses a path variable to search for these external commands.

echo $PATH                  // To see the directories defined in the $PATH variable.
                            NOTE : If the path variable does not have the location of a command or a program defined, running a command by itself will result in a failure.

which obs-studio           // To check if the location of a command (obs-studio) can be identified.
export PATH=$PATH:/opt/obs/bin // To add the path of a command (obs-studio) in $PATH environment variable.
which obs-studio            // It should display the path [opt/obs/bin/obs-studio] as output.


#

    BASH PROMPT
    It shows the logged in user and host systems details, it is editable.

[user@hostname]$        // This can be like [michael@prod-server]$
                        // $ is a User Prompt Symbol

    The bash prompt is controlled by special shell environment variables, one common one is PS1.
    PS1 : Prompt definition, the variable that defines what your terminal prompt looks like in bash.

    üß± 1Ô∏è‚É£ Basic printable characters

    You can use any normal text (letters, numbers, punctuation, emojis, etc.) directly in PS1.

    Example:
    PS1="Hello > "

    Produces:
    Hello >


    ‚úÖ Allowed:

    Letters: a-z A-Z

    Numbers: 0-9

    Symbols: !@#$%^&*()[]{}<>?/|;:'",.=-+_

    Emojis and Unicode (‚úÖ e.g. PS1="üêß \u@\h \$ ")


    üß© 2Ô∏è‚É£ Backslash escapes (special \ sequences)

    These are special placeholders Bash replaces dynamically.

    Here‚Äôs the full list (from the official Bash manual):

    Sequence	                        Meaning	                                            Example Output
    \a	                                ASCII bell (beep)	                                üîî sound
    \d	                                Date (e.g., "Sat Oct 18")	                        Sat Oct 18
    \D{format}	                        Custom date/time (strftime format)	                \D{%F %T} ‚Üí 2025-10-18 14:42:00
    \e	                                Escape character (useful for colors)	            ‚Äî
    \h	                                Hostname (short)	                                debian
    \H	                                Full hostname	                                    debian.localdomain
    \j	                                Number of jobs currently managed by shell	        0
    \l	                                Terminal device name (basename of tty)	            pts/0
    \n	                                Newline	                                            (starts a new line)
    \r	                                Carriage return	                                    ‚Äî
    \s	                                Shell name	                                        bash
    \t	                                Current time (HH:MM:SS)	                            14:42:36
    \T	                                Time (12-hour, with AM/PM)	                        02:42:36 PM
    \@	                                Time (12-hour with am/pm)	                        02:42 pm
    \A	                                Time (24-hour HH:MM)	                            14:42
    \u	                                Username	                                        alice
    \v	                                Bash version (short)	                            5.2
    \V	                                Bash version (long, e.g. 5.2.15)	                5.2.15
    \w	                                Current working directory	                        /home/alice/projects
    \W	                                Basename of \w (last part)	                        projects
    \!	                                History number of this command	                    132
    \#	                                Command number (since shell start)	                24
    \$	                                $ for user, # for root	                            $
    \nnn	                            Character with octal value nnn	                    e.g., \007 = BEL
    \\	                                A literal backslash	                                \
    \[	                                Start of non-printing sequence (for color codes)	‚Äî
    \]	                                End of non-printing sequence	                    ‚Äî


    üé® 3Ô∏è‚É£ ANSI color codes and formatting

    You can include ANSI escape codes to add color and style.
    You must wrap them in \[ \] to tell Bash they don‚Äôt take up screen space.

    Example	            Description
    \[\e[0m\]	        Reset all colors
    \[\e[31m\]	        Red text
    \[\e[32m\]	        Green text
    \[\e[33m\]	        Yellow text
    \[\e[34m\]	        Blue text
    \[\e[1m\]	        Bold
    \[\e[4m\]	        Underline

    Example:

    PS1="\[\e[1;32m\]\u@\h\[\e[0m\]:\[\e[1;34m\]\w\[\e[0m\]\$ "

    ‚Üí Shows green user@host, blue directory, and resets after.


    ‚öôÔ∏è 4Ô∏è‚É£ Variable and command substitutions

    You can embed shell variables or even commands in your prompt.

    üßÆ Variables:
    PS1="[$USER@$HOSTNAME] "


    ‚Üí [alice@debian]

    ‚ö° Command substitution:
    PS1="\u@\h:\$(date +%H:%M)\$ "


    ‚Üí alice@debian:14:43$

    (Note: use \$() not backticks, and escape $ if needed.)


    üß† 5Ô∏è‚É£ Conditional or dynamic parts

    You can include Bash expressions like:

    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '


    ‚Üí Only prints ($debian_chroot) if that variable is set.


    ‚ö†Ô∏è 6Ô∏è‚É£ What NOT to do

    ‚ùå Don‚Äôt forget to wrap non-printing sequences (color codes) with \[ \].

    Otherwise, line wrapping breaks.

    ‚ùå Don‚Äôt use raw control characters (except through escapes).

    ‚ùå Avoid very long or slow command substitutions ‚Äî they‚Äôll make your prompt lag.


    ‚úÖ 7Ô∏è‚É£ Example: A fancy colored PS1

    PS1='\[\e[1;32m\]\u@\h\[\e[0m\]:\[\e[1;34m\]\w\[\e[0m\]\[\e[1;33m\] $(date +%H:%M:%S)\[\e[0m\]\$ '


    Might look like:

    alice@debian:/home/alice/projects 14:45:12$

    (with username green, path blue, time yellow)
#

echo $PS1
\[\]\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ \[\]

    
    1Ô∏è‚É£ What is $PS1?

    $PS1 is the primary prompt string ‚Äî it tells Bash what to display when waiting for a command.

    If $PS1 contains \u@\h:\w\$ , your prompt might look like:

user@hostname:/home/user$

    
    2Ô∏è‚É£ Let‚Äôs decode your PS1 step by step

SEGMENT 1: \[\]\[\e]0;\u@\h: \w\a\]

    \e = ESC (start of an escape sequence)

    ]0;... = set terminal window title

    \u = current username

    \h = hostname (first part before .)

    \w = current working directory

    \a = BEL character (ends the title-setting command)

    \[ and \] = mark ‚Äúnon-printing characters‚Äù (so Bash can correctly handle cursor position and line wrapping)


    üß† So this portion sets your terminal title bar (not the visible prompt line).

    ‚úÖ Example:
    If your user is alice, host is debian, and you‚Äôre in /home/alice/projects,
    your terminal window title (the title bar, not the prompt) becomes:

    alice@debian: /home/alice/projects


SEGMENT 2: ${debian_chroot:+($debian_chroot)}

    ${var:+value} means: if $var is set and non-empty, substitute value; otherwise, substitute nothing.

    So:

    If you are inside a Debian chroot environment (e.g. /etc/debian_chroot exists), this shows something like (chrootname)

    Otherwise, nothing is displayed.

    ‚úÖ Example:
    If $debian_chroot=‚Äúbuster‚Äù, this part becomes:

    (buster)


SEGMENT 3: \[\033[01;32m\]\u@\h\[\033[00m\]

    This sets colored text for username@hostname.

    \033 = ESC (same as \e)

    [01;32m = bright green text

    \u@\h = username@hostname

    [00m = reset color to default

    ‚úÖ Example:
    Appears as:

    alice@debian

    (in green)


SEGMENT 4: :

    Just a literal colon separating the hostname from the working directory.


SEGMENT 5: \[\033[01;34m\]\w\[\033[00m\]

    Same color pattern:

    \033[01;34m = bright blue

    \w = current directory (full path, but with ~ for home)

    \033[00m = reset color

    ‚úÖ Example:

    If you are in /home/alice/projects, this appears as:

    /home/alice/projects

    (in blue)


SEGMENT 6: \$

    \$ = prints # if you are root, $ if you are normal user

    = a space for readability

    ‚úÖ Example:

    $

    (for regular user)
    or

    #

    (for root)


SEGMENT 7: \[\]

    These empty \[ \] pairs mark the end ‚Äî they don‚Äôt change anything; just delimit non-printing characters.

    ‚úÖ Final Output Example

    If:

    user = alice

    host = debian

    directory = /home/alice/projects

    not in chroot

    normal user

    You‚Äôll see:

    alice@debian:/home/alice/projects$ 


    With:

    alice@debian in green

    /home/alice/projects in blue

    $ in default color

    Terminal window title set to ‚Äúalice@debian: /home/alice/projects‚Äù


üé® Summary Table
==================

Code	                            Meaning	                            Example Output
\u	                                Username	                        alice
\h	                                Hostname	                        debian
\w	                                Working directory	                /home/alice/projects
\e / \033	                        Escape character for ANSI codes	    ‚Äî
[01;32m	                            Bright green text	                ‚Äî
[01;34m	                            Bright blue text	                ‚Äî
[00m	                            Reset color	                        ‚Äî
\$	                                $ (user) or # (root)	            $
${debian_chroot:+($debian_chroot)}	Show chroot name if set	            (buster)
\[ \]	                            Mark non-printing sequences	        ‚Äî


#

    LINUX KERNEL
    It is a major component of an operating system and is the core interface between a computer's hardware and its processes.

    +-------------------------------------------------------+
    |                    User Space                         |
    |-------------------------------------------------------|
    |  Applications / User Programs                         |
    |  (e.g., Browser, Editor, Games, etc.)                 |
    |                                                       |
    |  -> Interact with the kernel via System Calls (API)   |
    +-------------------------------------------------------+
                            |
                            |  System Calls / Interrupts
                            v
    +-------------------------------------------------------+
    |                    Kernel Space                       |
    |-------------------------------------------------------|
    |  KERNEL = Core part of the Operating System           |
    |                                                       |
    |  - Process Management                                 |
    |  - Memory Management                                  |
    |  - Device Drivers                                     |
    |  - File System Management                             |
    |  - Networking Stack                                   |
    |                                                       |
    |  -> Mediates access between software and hardware     |
    +-------------------------------------------------------+
                            |
                            |  Hardware Abstraction Layer
                            v
    +-------------------------------------------------------+
    |                     Hardware                          |
    |-------------------------------------------------------|
    |  CPU | Memory | Disk | Devices | Network Interfaces   |
    +-------------------------------------------------------+

#

    What the Kernel Does
    ======================

    Here are its main jobs (in plain language):

    Manages memory ‚Äì decides how RAM is used and shared among apps.

    Controls processes ‚Äì starts, stops, and schedules programs (CPU scheduling).

    Handles hardware ‚Äì communicates with the CPU, disks, keyboard, etc., through device drivers.

    Manages system calls ‚Äì lets apps safely ask the OS to do things (like read a file or send data).

#

    How It Works (Step-by-step Example)
    =====================================

    Let‚Äôs say you click ‚ÄúSave‚Äù in a text editor.

    App (user program) says:

    ‚ÄúHey OS, please save this file!‚Äù

    Library translates that request into a system call.

    Kernel takes over:

    Finds space on the disk,

    Writes the data,

    Updates the file system.

    Hardware (disk) does the actual writing.

    So the kernel makes sure everything happens safely and correctly ‚Äî no app directly touches hardware.

                    +-------------------------+
                    |      User Programs      |
                    +-----------+-------------+
                                |
                                |  System Calls (Requests)
                                v
    +------------------------------------------------------+
    |                      KERNEL                          |
    |------------------------------------------------------|
    |  Process Control   ‚Üí creates, runs, and stops tasks   |
    |  Memory Manager    ‚Üí gives programs RAM safely        |
    |  File System       ‚Üí reads/writes files               |
    |  Device Drivers    ‚Üí talks to hardware                |
    |  Networking        ‚Üí handles data over network        |
    +------------------------------------------------------+
                                |
                                |  Hardware Instructions
                                v
    +------------------------------------------------------+
    |                     HARDWARE                         |
    |     CPU | Memory | Disk | Network | Devices          |
    +------------------------------------------------------+


#

    Two ‚ÄúWorlds‚Äù Inside Your Computer
    ==================================

    The CPU runs in two main modes:

    +--------------------+
    | User Mode          | ‚Üí Apps run here
    | Limited Access     |
    | Needs permission   |
    +--------------------+
            |
            | System Call (Switch)
            v
    +--------------------+
    | Kernel Mode        | ‚Üí Kernel runs here
    | Full access to HW  |
    | Manages resources  |
    +--------------------+

#

    +-------------------------------------------------------+
    |                     User Space                        |
    |-------------------------------------------------------|
    |  Web Browser, Bash, Docker, kubelet, nginx, sshd      |
    |  ‚îî‚îÄ> Use system calls to ask kernel for resources     |
    +-------------------------------------------------------+
                        ‚Üì   ‚Üë  (system calls, interrupts)
    +-------------------------------------------------------+
    |                     Kernel Space                      |
    |-------------------------------------------------------|
    |  Memory Manager, Process Scheduler, File Systems      |
    |  Network Stack, Device Drivers, Security Modules      |
    +-------------------------------------------------------+
                        ‚Üì
    +-------------------------------------------------------+
    |                     Hardware                          |
    |-------------------------------------------------------|
    |  CPU, RAM, Disk, NIC, GPU, Devices                    |
    +-------------------------------------------------------+



    This separation keeps the system stable and secure ‚Äî
    if an app crashes, it doesn‚Äôt crash the whole system.

#

    User Space
    ===========

    These are programs and services that run in the normal, restricted mode.

    Category	                        Examples	                                Notes
    User Applications	                Chrome, VS Code, Firefox, Slack	            Directly used by users
    System Utilities	                ls, cat, top, systemctl	                    Run commands and tools
    Background Services (daemons)	    sshd, nginx, containerd, dockerd	        Managed by the OS but run in user space
    Kubernetes Processes	            kubelet, kube-proxy, kube-apiserver, etcd	All these are user-space binaries that rely on the kernel to do real work
    Shells	                            bash, zsh, fish	                            Where you type commands
    User Libraries	                    libc, OpenSSL, glibc	                    Provide system call interfaces to the kernel

    Key point:
    -----------
    User-space programs request services from the kernel using system calls ‚Äî e.g., read files, open sockets, allocate memory.

#

    Kernel Space
    =============

    This is where core operating system components and device drivers live.

    Category	                        Examples	                                                Notes
    Core Kernel	                        Linux kernel itself (vmlinux)	                            Manages hardware, memory, CPU
    Device Drivers	                    e1000e (Ethernet), nvme, usb-storage	                    Control physical devices
    File Systems	                    ext4, xfs, btrfs, overlayfs	                                Handle file operations
    Network Stack	                    netfilter, iptables, TCP/IP	                                Handles all network traffic
    Process Scheduler	                Schedules CPU time for processes	                        Determines which process runs next
    Memory Manager	                    Handles virtual memory, paging, caching	                    Ensures isolation between processes
    Interrupt Handlers	                Handle hardware events (e.g., keyboard input, NIC packets)	Executed by kernel directly

    Key point:
    -----------
    Kernel code runs with high privileges ‚Äî a crash here can bring down the entire system.


#

    Summary
    Aspect	                User Space	                    Kernel Space
    Privilege Level	        Low (restricted)	            High (full access)
    Crashes Affect	        Only that process	            Entire system
    Runs What	            Apps, daemons, system tools	    Kernel, drivers, schedulers
    Example Processes	    bash, nginx, kubelet	        ksoftirqd, systemd-udevd, ext4, netfilter
    Interface	            System calls (API)	            Hardware interrupts, syscalls handler

#

    KERNEL VERSIONS
    ================


uname                       // To display information about the kernel.

uname -r                    // To print the kernel version.


6.6.87.2-microsoft-standard-WSL2


    ‚îå‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ6 ‚îÇ6 ‚îÇ87  ‚îÇ2 ‚îÇ -microsoft-standard-WSL2     ‚îÇ
    ‚îî‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ  ‚îÇ   ‚îÇ   ‚îÇ             ‚îÇ
    ‚îÇ  ‚îÇ   ‚îÇ   ‚îÇ             ‚îî‚îÄ‚ñ∫ Distro/Build Tag (WSL2 build by Microsoft)
    ‚îÇ  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚ñ∫ Optional local patch or revision (non-standard)
    ‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Patch version (bug fixes)
    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Minor version (feature updates)
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ **Major version**


    Kernel: 6.6.87.2-microsoft-standard-WSL2

#

    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Major (6)  ‚îÇ Minor (6)  ‚îÇ Patch (87) ‚îÇ Rev (2)    ‚îÇ Build Tag (WSL2)           ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

#

    Correct interpretation:
    Part	                    Meaning	                        Example	                    Notes
    6	                        Major version	                6	                        Big architectural release (Kernel 6.x series)
    6	                        Minor version	                6	                        Adds new features, updates, and subsystem changes
    87	                        Patch level	                    87	                        Bug and stability fixes
    2	                        Local patch or rebuild revision	2	                        Used internally by distro maintainers (here, Microsoft‚Äôs WSL2 team)
    -microsoft-standard-WSL2	Distro tag	                    -microsoft-standard-WSL2	Identifies this kernel as a custom Microsoft build for WSL2

#

    Why it looks confusing
    ------------------------

    Historically:

    Before 2003, Linux used a three-number scheme (2.6.32 ‚Üí major.minor.patch).

    Now it‚Äôs two main numbers (major.minor), and the rest are patch/build identifiers.

    So for:
    
    6.6.87.2


    you can think of it as:
    Kernel 6 (major) ‚Üí Minor 6 ‚Üí Patch 87 ‚Üí Local revision 2

#

    How WSL2 adds extra info
    -------------------------

    Microsoft compiles its own Linux kernel for WSL2, and appends:

    -microsoft-standard-WSL2


    That‚Äôs not part of the Linux versioning scheme ‚Äî it just tells you this kernel was built and tuned for Windows Subsystem for Linux 2.

#

    EXAMPLE - Connecting a USB drive to PC
    ---------------------------------------

STEP 1: Physical Connection (Hardware Layer)

    - You insert the USB stick into the port.

    Hardware
    ‚îî‚îÄ‚îÄ USB Connector ‚Üí USB Controller (chip on motherboard)


    - The USB controller detects a new electrical signal ‚Äî

    it notifies the CPU that a new USB device is connected via a hardware interrupt.


 STEP 2: Kernel Interrupt Handling (Kernel Space)

    - When the hardware interrupt fires:

    The CPU switches into kernel mode.

    The USB subsystem in the Linux kernel gets the signal.

    The kernel loads or activates the correct USB driver.

    Example kernel modules involved:

    usbcore.ko        ‚Üê Core USB support
    xhci_hcd.ko       ‚Üê USB 3.0 controller driver
    usb_storage.ko    ‚Üê Generic USB mass storage driver
    sd_mod.ko         ‚Üê SCSI disk module (for storage devices)


    - The kernel now treats the USB stick like a block device and assigns it a name like /dev/sdb.


 STEP 3: Device Initialization (Kernel Space)

    The kernel:

    Reads the USB device descriptor (metadata about the device).

    Allocates resources (buffers, endpoints).

    Registers the new device in /sys (sysfs) and /dev.

    You can see this with:

dmesg | tail                    // To display messages from an area of the kernel called the ring buffer, it contains hardware logs created durting kernel loading.
dmesg | grep -i usb

    You‚Äôll get logs like:

    [1234.567890] usb 2-1: new high-speed USB device number 4 using xhci_hcd
    [1234.678901] usb 2-1: New USB device found, idVendor=0781, idProduct=5567
    [1234.789012] scsi 6:0:0:0: Direct-Access     SanDisk  Ultra 16GB 1.00 PQ: 0 ANSI: 6
    [1234.890123] sd 6:0:0:0: [sdb] 30535680 512-byte logical blocks


    - At this point, the kernel fully recognizes the USB stick and exposes it to user space as /dev/sdb.

 STEP 4: User Space Detection

    - In user space, background services like udev or systemd-udevd detect the new device event from the kernel.

    They:

    Create a device file in /dev/ (like /dev/sdb1).

    May automatically mount it (on desktop systems) using tools like udisks2 or gvfs.

    You can see it:

lsblk


    Output:

    sdb     8:16   1  14.5G  0 disk 
    ‚îî‚îÄsdb1  8:17   1  14.5G  0 part  /media/user/USB


 STEP 5: Mounting (User Space + Kernel Space)

    When you or the system mounts the drive:

    sudo mount /dev/sdb1 /media/usb


    Here‚Äôs what happens:

    User space command mount (binary) runs.

    It makes a system call to the kernel‚Äôs VFS (Virtual File System) layer.

    The kernel loads the correct filesystem driver (e.g., vfat.ko, exfat.ko, ntfs.ko).

    The kernel reads the filesystem metadata and connects it to /media/usb.

    Now the drive is accessible.


STEP 6: Using the Drive (User Space ‚Üî Kernel Space)

    When you open or copy a file:

    User-space apps (cp, cat, file explorer) request reads/writes via system calls (read(), write()).

    The kernel filesystem layer translates those requests into block I/O.

    The USB storage driver sends data over the USB bus to/from the drive.

    User Space
    ‚Üì
    System Calls (read/write)
    ‚Üì
    Kernel Space
    ‚îú‚îÄ‚îÄ VFS ‚Üí Filesystem driver (FAT, NTFS)
    ‚îú‚îÄ‚îÄ Block layer
    ‚îú‚îÄ‚îÄ USB storage driver
    ‚Üì
    Hardware (USB Controller ‚Üî USB Drive)


STEP 7: Safely Removing the Drive

    When you click ‚ÄúEject‚Äù or run:

sudo umount /media/usb


    User-space command umount calls kernel‚Äôs VFS to unmount.

    The kernel:

    Flushes any cached data to disk,

    Releases file handles,

    Notifies the USB driver subsystem.

    Once idle, the USB driver signals the controller ‚Äî safe to remove.


#

    UDEV
    =====
    udev (userspace /dev) is the device manager for the Linux kernel, operating in user space. It handles the dynamic creation and removal of device nodes in the /dev directory.

    Responsibilities of udev:
    --------------------------

    Creates/removes device files under /dev dynamically when hardware is added/removed.

    Applies permissions and ownership to devices.

    Creates symlinks (like /dev/disk/by-uuid/).

    Loads firmware if needed.

    Runs user-defined scripts or actions when a device is detected (via udev rules).

    
    Example use case:

    When you plug in a USB drive:

    Kernel detects it and emits a udev event.

    udev listens for these events and:

    Creates the device node (e.g., /dev/sdb).

    Applies rules (e.g., setting permissions, running a script).

    Optionally triggers auto-mount (if configured via other subsystems).


#

    UDEVADM
    ========
    udevadm is the administrative tool to interact with the udev daemon. Think of it as the command-line interface to inspect, control, and debug udev.

    Common udevadm commands:

    Command	                        Purpose
    udevadm info	                Query udev database for device information.
    udevadm trigger	                Manually trigger udev events.                       // Useful after modifying udev rules to test them without rebooting.
    udevadm settle	                Wait for all current events to finish.
    udevadm monitor	                Watch udev events in real-time. (Listens to kernel uevents)
    udevadm control	                Modify udev daemon behavior (e.g., reload rules).
    udevadm control --reload-rules  Reload udev rules


#

    Where are the udev rules?
    --------------------------

    System rules: /usr/lib/udev/rules.d/

    Admin/custom rules: /etc/udev/rules.d/

    Udev rules have filenames like 10-local.rules or 99-usb.rules and define match-action pairs.

#

    LSPCI
    ======
    lspci is a command-line tool in Linux used to list all PCI (Peripheral Component Interconnect) devices on your system.

    It's part of the "pciutils package" and provides details about hardware devices connected to the PCI bus such as such as graphics cards, network cards, USB controllers, sound cards, ethernet cards, RAID controllers, video cards, directly attached wireless adapters

    PCI -> Peripheral Component Interconnect


     What is the PCI bus?
     ---------------------

    The PCI bus is a hardware bus used for attaching peripheral devices to a computer's motherboard. Common on desktops, laptops, and servers.


     What does lspci do?
     --------------------

    It reads from:

    /sys/bus/pci/devices/

    /proc/bus/pci/

    And uses the PCI ID database to translate numeric IDs into human-readable names.


    Basic Usage:
    -------------

    Command             Description
    lspci               View all PCI devices
    lspci -v            Get detailed info (verbose)
    lspci -vv           Show even more details
    lspci -k            Show kernel driver in use
    lspci -mm           Show in machine-readable format
    lspci -n            Display numeric device/vendor IDs


$ lspci
00:00.0 Host bridge: Intel Corporation 8th Gen Core Processor Host Bridge
00:02.0 VGA compatible controller: Intel Corporation UHD Graphics 620
00:14.0 USB controller: Intel Corporation Sunrise Point-LP USB 3.0 xHCI Controller
00:1f.3 Audio device: Intel Corporation Sunrise Point-LP HD Audio

    Each line shows:

    Bus address (00:02.0)

    Device class (VGA compatible controller)

    Vendor & model (Intel Corporation UHD Graphics 620)


    PCI ID Database
    ---------------

    To show readable vendor/device names, lspci uses:

    /usr/share/misc/pci.ids or /usr/share/hwdata/pci.ids

    You can update it with:

#

    LSBLK
    ======
    lsblk (List Block Devices) is a command-line utility in Linux used to list information about block devices ‚Äî like hard drives, SSDs, USB drives, partitions, and loop devices.

    It's part of the "util-linux" package and is commonly used for inspecting storage devices and their structure.

    Basic Usage

lsblk

    Example output:

NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda      8:0    0  500G  0 disk 
‚îú‚îÄsda1   8:1    0  100G  0 part /
‚îú‚îÄsda2   8:2    0  300G  0 part /home
‚îî‚îÄsda3   8:3    0  100G  0 part [SWAP]

    Here:

    sda is a disk

    sda1, sda2, sda3 are partitions

    Mounted at /, /home, and swap

    Common Options
    Command	            Description
    lsblk -f	        Show filesystem info (type, UUID, label)
    lsblk -a	        List all devices (including empty ones)
    lsblk -d	        Only show top-level disks (not partitions)
    lsblk -e 7	        Exclude loop devices (major number 7)
    lsblk -o            NAME,SIZE,FSTYPE,MOUNTPOINT	Customize columns
    lsblk -J	        JSON output (useful for scripts)


    Bonus Tip: Combine with blkid

    lsblk is great for hierarchy and mount info.
    blkid shows detailed filesystem metadata (UUIDs, labels, types).

#

    MAJOR-MINOR NUMBER and DEVICE TYPE
    =============================

    What is a Major Number?

    The Major Number in Linux identifies the driver associated with a device.

    When the kernel sees a device, it uses the major number to know which kernel module (driver) should handle that device.

    Example:

$ ls -l /dev/sda
brw-rw---- 1 root disk **8, 0** Oct 18 10:00 /dev/sda

    b ‚Üí Block device
    8 ‚Üí Major number ‚Üí Identifies the disk driver (sd for SCSI disks)
    0 ‚Üí Minor number ‚Üí Identifies the specific device (e.g., partition or disk)


    Major vs Minor Number
    ----------------------

    Number Type	            Meaning
    Major	                Identifies the device driver
    Minor	                Identifies the specific instance of the device the driver controls


    Common Major Numbers
    ---------------------
    Major Number	        Device Type
    8	                    SCSI/SATA disks (sd)
    1	                    RAM disk (/dev/ram*)
    3	                    IDE hard drives (hd)
    7	                    Loop devices (/dev/loop*)
    180	                    USB devices
    202	                    Xen virtual block device
    254	                    Device mapper (e.g., LVM)

    You can see a full list in /proc/devices:
    cat /proc/devices


#

    What is a Device Type?
    =======================

    Device types tell Linux how to interact with the device:

    Type	            Description
    b	                Block device ‚Äì reads/writes data in blocks (e.g., disks, USB drives)
    c	                Character device ‚Äì reads/writes data as a stream (e.g., keyboards, serial ports)
    p	                FIFO/pipe ‚Äì for inter-process communication


    Example:

$ ls -l /dev/tty0
crw--w---- 1 root tty 4, 0 Oct 18 10:00 /dev/tty0

c ‚Üí Character device
4 ‚Üí Major (TTY driver)
0 ‚Üí Minor


#

    LSCPU
    ======
    lscpu is a Linux command-line utility that displays CPU architecture information.
    It's a quick way to inspect details about the system‚Äôs processor(s) ‚Äî such as cores, threads, sockets, CPU family, virtualization support, and more.

    It pulls information from /proc/cpuinfo and sysfs.


    What does lscpu show?
    -----------------------

    Here‚Äôs a sample output:
    Architecture:            x86_64
    CPU op-mode(s):          32-bit, 64-bit
    Byte Order:              Little Endian
    CPU(s):                  8
    On-line CPU(s) list:     0-7
    Thread(s) per core:      2
    Core(s) per socket:      4
    Socket(s):               1
    Vendor ID:               GenuineIntel
    Model name:              Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz
    Virtualization:          VT-x
    L1d cache:               32K
    L2 cache:                256K
    L3 cache:                8192K


    Key Fields Explained:

    Field	                Meaning
    Architecture	        CPU architecture (e.g., x86_64, aarch64)
    CPU(s)	                Total number of logical processors (threads)
    Thread(s) per core	    Indicates hyperthreading (2 = enabled)
    Core(s) per socket	    Physical cores per CPU
    Socket(s)	            Number of physical CPUs (usually 1 in laptops/desktops)
    Model name	            CPU branding info
    Virtualization	        Whether virtualization is supported (e.g., VT-x, AMD-V)
    Caches	                Sizes of L1, L2, L3 CPU caches


    Example Use Cases
    
    Command                 Description
    lscpu                   Show CPU layout
    lscpu -J                Display info in JSON format
    lscpu --parse=NUMA      Show NUMA info (if applicable)
    lscpu | grep '^CPU(s)'  Show only specific fields


#

    Difference vs /proc/cpuinfo
    ----------------------------

lscpu:              Structured, high-level summary (uses sysfs)

/proc/cpuinfo:      Raw per-CPU core details (e.g., flags, bugs)

Use cat /proc/cpuinfo if you need flags like sse4_2, vmx, aes, etc.


#

    LSMEM
    ======
    lsmem is a Linux command-line tool used to display information about memory (RAM) blocks in the system.

    It shows how memory is organized, online/offline, available, and reserved, especially useful on systems with hot-pluggable or NUMA memory.

    Basic Usage

lsmem

RANGE                                       SIZE         STATE       REMOVABLE       BLOCK
0x0000000000000000-0x000000007fffffff       2G           online      yes             0
0x0000000100000000-0x000000017fffffff       2G           online      yes             1

Memory block size:       2G
Total online memory:     4G
Total offline memory:    0B

    What It Shows:
    ---------------
    Field	        Meaning
    RANGE	        Physical address range of a memory block
    SIZE	        Size of each memory block
    STATE	        online (available) or offline (not available to the OS)
    REMOVABLE	    Whether the memory block can be safely removed (hot-unplug)
    BLOCK	        Logical block number assigned by the kernel

    Useful Options
    Option	                Description
    -a or --all	            Show both online and offline memory blocks
    -b	                    Display sizes in bytes
    -J	                    JSON output
    --split=STATE	        Show summary grouped by online/offline state
    --output=FIELD,...	    Show only selected fields

#

    When is lsmem Useful?
    ----------------------

    On servers with hot-pluggable memory (common in virtual machines or enterprise systems).

    To check which memory blocks are online/offline.

    When managing NUMA nodes or doing low-level system tuning.

    For debugging memory issues in advanced environments.

#

    FREE
    =====
    The **free** command displays a summary of the system‚Äôs memory usage, including:

    RAM (main memory)
    Swap space (virtual memory)
    Buffers and cache used by the kernel

    It's one of the simplest and fastest ways to check how much memory is used, free, and available.


    Basic Usage
    ------------
free

              total        used        free      shared  buff/cache   available
Mem:        16337752     2187456     9211232      321652     4949056    13509264
Swap:        2097148           0     2097148


Columns Explained

Column	            Meaning
total	            Total memory or swap installed
used	            Memory used (including buffers/cache unless using -h)
free	            Completely unused memory
shared	            Memory used by tmpfs (shared between processes)
buff/cache	        Memory used by kernel buffers and filesystem cache
available	        Estimated memory available for new apps (without swapping)


    Total RAM vs Available RAM
    ---------------------------

    If you‚Äôre confused why "used" memory looks high ‚Äî remember:

    Linux uses free RAM as disk cache to speed things up. That memory is reclaimable and not "wasted".

    "available" is a better measure of how much memory you really have free for apps.

#

    LSHW
    =====
    lshw (short for List Hardware) is a powerful command-line tool in Linux that displays detailed information about your system‚Äôs hardware ‚Äî including CPU, memory, disks, network interfaces, motherboard, and more.

    It‚Äôs like opening up your computer and reading the labels on each component ‚Äî but from the terminal.


    What Can lshw Show?

    It pulls information from /proc, /sys, and DMI/SMBIOS, giving deep, low-level details, such as:

    CPU: model, speed, capabilities
    RAM: size, configuration, slots
    Motherboard: vendor, model
    BIOS: version, date
    Storage: model, size, partitions
    Network: interfaces, speed, capabilities


    Basic Usage

sudo lshw
*-cpu
   description: CPU
   product: Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz
   vendor: Intel Corp.
   physical id: 1
   bus info: cpu@0
   size: 2112MHz
   capacity: 4200MHz
   width: 64 bits

*-memory
   description: System Memory
   physical id: 2
   size: 16GiB

*-disk
   description: ATA Disk
   product: Samsung SSD 970
   size: 512GiB


    Useful Options

    Command	                            Description
    sudo lshw	                        Full detailed output
    sudo lshw -short	                Summary table (one-liner per device)
    sudo lshw -class cpu	            Show only CPU details
    sudo lshw -class memory	            Only memory info
    sudo lshw -class disk	            Only storage info
    sudo lshw -html > system.html	    Export to HTML file
    sudo lshw -json	                    Output in JSON format


    When to Use lshw
    -----------------

    Hardware inventory collection

    Checking available RAM slots or disk models

    Verifying hardware before/after upgrades

    Troubleshooting compatibility issues

    Creating system reports (HTML/JSON)

#

    LINUX BOOT SEQUENCE
    ====================

1. BIOS / UEFI Initialization

    What happens:

    When you power on your computer, the BIOS (legacy) or UEFI (modern firmware) takes control.
    It performs a POST (Power-On Self-Test) ‚Äî checks CPU, RAM, and hardware.
    It finds a bootable device (HDD, SSD, USB) using the boot order.
    It loads the first-stage bootloader (from MBR or EFI partition) into memory and runs it.

    Key Files:

    BIOS ‚Üí Master Boot Record (MBR)
    UEFI ‚Üí EFI System Partition (ESP)

    
2. Bootloader Stage (GRUB, systemd-boot, LILO, etc.)

    What happens:
    The bootloader is responsible for loading the Linux kernel into memory.
    It can display a boot menu if you have multiple OSes or kernels.
    It also loads an initial RAM filesystem (initramfs) to help the kernel boot.

    Example (GRUB):

    GRUB loads:
    ‚Üí Kernel image: /boot/vmlinuz-6.6.87
    ‚Üí Initramfs:    /boot/initrd.img-6.6.87
    ‚Üí Passes boot parameters to kernel


3. Kernel Initialization

    What happens:
    The kernel takes over from the bootloader.
    It uncompresses itself into memory.

    Initializes:
        CPU, memory management
        Device drivers (for essential hardware)
        Mounts initramfs as temporary root filesystem

    Kernel tasks:
    Detects and configures hardware
    Mounts the real root filesystem (e.g., /dev/sda1)
    Starts the first user-space process: init (PID 1)


4. Initramfs (Initial RAM Filesystem)

    What happens:
    Temporary, small root filesystem stored in RAM.

    Contains tools and scripts to:
        Detect storage devices
        Load drivers
        Mount real root filesystem (/)

    Once the real root is ready, it‚Äôs switched, and initramfs is discarded.


5. System Initialization (init / systemd / upstart)

    What happens:
    The init system is the first process started by the kernel.
    On modern Linux, this is typically systemd (PID 1).

    It initializes:
        Target units (like runlevels)
        Services, daemons
        Network, logging, user sessions

    Older init systems:
    SysVinit (/etc/init.d/)
    Upstart (Ubuntu legacy)


6. Runlevel or Target Activation

    What happens:
    The system enters a runlevel (SysVinit) or target (systemd).

    Examples:
        Multi-user mode (no GUI)
        Graphical mode (with display manager)

    Services like sshd, nginx, cron, etc., are started.


7. User Login

    What happens:

    Once systemd reaches the target:
        The getty process starts on terminals (for text login)
        Or a display manager starts for GUI login (e.g., GDM, LightDM)

    You can now log in, and your shell (bash, zsh) starts ‚Äî in user space.

#

    LINUX BOOT SEQUENCE DIAGRAM
    =============================

    +--------------------------------------------------------------+
    |                        Power ON                              |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | BIOS / UEFI                                                  |
    |--------------------------------------------------------------|
    | - Firmware on motherboard (EEPROM chip)                      |
    | - Performs POST (Power-On Self-Test)                         |
    | - Locates boot device via Boot Order                         |
    | - Loads Bootloader from:                                     |
    |     ‚Ä¢ BIOS ‚Üí Master Boot Record (MBR) on disk (first 512 bytes)|
    |       Path:  [sector 0 of disk]                              |
    |     ‚Ä¢ UEFI ‚Üí EFI System Partition (ESP)                      |
    |       Path:  /boot/efi/EFI/<distro>/grubx64.efi              |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | Bootloader (e.g., GRUB, systemd-boot, LILO)                  |
    |--------------------------------------------------------------|
    | - Loads Kernel and Initramfs into memory                     |
    | - Provides boot menu                                         |
    | - Passes parameters to kernel                                |
    | Files typically located at:                                  |
    |   ‚Ä¢ /boot/grub/grub.cfg          ‚Üê GRUB configuration        |
    |   ‚Ä¢ /boot/vmlinuz-<version>      ‚Üê Kernel image              |
    |   ‚Ä¢ /boot/initrd.img-<version>   ‚Üê Initramfs (initrd)        |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | Linux Kernel Initialization                                  |
    |--------------------------------------------------------------|
    | - Kernel (vmlinuz) unpacks into memory                       |
    | - Initializes CPU, memory, drivers                           |
    | - Mounts temporary root (initramfs)                          |
    | - Starts first user-space process: /sbin/init (PID 1)        |
    | Files/paths:                                                 |
    |   ‚Ä¢ /boot/vmlinuz-<version>     ‚Üê kernel binary              |
    |   ‚Ä¢ /proc, /sys, /dev           ‚Üê virtual kernel filesystems |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | Initramfs (Initial RAM Filesystem)                           |
    |--------------------------------------------------------------|
    | - Temporary root filesystem (in RAM)                         |
    | - Contains tools & scripts for early boot                    |
    | - Mounts real root (e.g. /dev/sda1)                          |
    | - Switches root to the real filesystem                       |
    | Files/paths:                                                 |
    |   ‚Ä¢ /boot/initrd.img-<version>  ‚Üê compressed cpio archive    |
    |   ‚Ä¢ /init (inside initramfs)    ‚Üê script that mounts rootfs  |
    |   ‚Ä¢ /etc/fstab                  ‚Üê mount instructions         |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | Init System (systemd / SysVinit / Upstart)                   |
    |--------------------------------------------------------------|
    | - First process started by kernel (PID 1)                    |
    | - Initializes services and targets                           |
    | - Prepares user environment                                  |
    | Common file locations:                                       |
    |   ‚Ä¢ /sbin/init ‚Üí usually a symlink to /lib/systemd/systemd   |
    |   ‚Ä¢ /etc/systemd/system/       ‚Üê custom unit files           |
    |   ‚Ä¢ /lib/systemd/system/       ‚Üê default unit files          |
    |   ‚Ä¢ /etc/inittab (for SysVinit)                              |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | Runlevel / Target Activation                                 |
    |--------------------------------------------------------------|
    | - Brings up all configured services and daemons              |
    | - Mounts local & network filesystems                         |
    | - Enables networking, logging, cron, etc.                    |
    | Files/paths:                                                 |
    |   ‚Ä¢ /etc/systemd/system/multi-user.target.wants/             |
    |   ‚Ä¢ /etc/rc*.d/ (for SysVinit scripts)                       |
    |   ‚Ä¢ /etc/fstab (for mounting drives)                         |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | User Space (Login / Shell / GUI)                             |
    |--------------------------------------------------------------|
    | - getty ‚Üí login prompt on terminal                           |
    | - GUI ‚Üí Display Manager (GDM, LightDM)                       |
    | - User logs in ‚Üí shell (bash, zsh) starts                    |
    | - Desktop environment starts (if GUI)                        |
    | User-space binaries and configs:                             |
    |   ‚Ä¢ /bin/, /usr/bin/        ‚Üê user commands (ls, cat, bash)  |
    |   ‚Ä¢ /etc/passwd, /etc/shadow ‚Üê user info                     |
    |   ‚Ä¢ /home/<user>/           ‚Üê user data                      |
    +--------------------------------------------------------------+


#

ls -l /sbin/init                        // To check the init system used

lrwxrwxrwx 1 root root 22 Jul 11 20:52 /sbin/init -> ../lib/systemd/systemd

#

    RUNLEVEL
    =========
    A runlevel is a mode of operation in traditional Linux systems (especially those using SysVinit) that defines what services and processes should be running.

    Think of it as the system‚Äôs operational state ‚Äî
    for example, ‚Äúsingle-user mode,‚Äù ‚Äúmulti-user mode,‚Äù or ‚Äúgraphical mode.‚Äù


    How Runlevels Work (SysVinit System)
    -------------------------------------

    When the system boots:
    The kernel starts the init process (PID 1).
    The init program reads /etc/inittab to determine which runlevel to start in.
    Based on the runlevel, init runs scripts from directories like /etc/rcX.d/
    (where X = runlevel number).

    Each runlevel defines what services should start or stop.


    Standard Linux Runlevels
    -------------------------
    Runlevel	        Name / Mode	                        Description
    0	                Halt	                            Shuts down the system
    1	                Single-user mode	                Maintenance mode ‚Äî only root user, no networking
    2	                Multi-user (no network)	            Multiple users, no network services (rarely used)
    3	                Multi-user (text mode)	            Normal multi-user mode with networking (no GUI)
    4	                Undefined / Custom	                Not used by default ‚Äî available for custom configs
    5	                Graphical mode	                    Multi-user with networking and GUI (X11 or Wayland)
    6	                Reboot	                            Reboots the system


    Runlevel Directory Structure

    Each runlevel has its own folder in /etc/:

    /etc/rc0.d/    ‚Üí scripts to run when entering runlevel 0
    /etc/rc1.d/    ‚Üí scripts for single-user mode
    /etc/rc2.d/    ‚Üí scripts for multi-user mode
    /etc/rc3.d/    ‚Üí scripts for full multi-user mode
    /etc/rc5.d/    ‚Üí scripts for GUI mode
    /etc/rc6.d/    ‚Üí scripts for reboot

    Inside each directory:

    Files starting with S ‚Üí services to Start
    Files starting with K ‚Üí services to Kill (stop)

    Example:
    /etc/rc3.d/
        ‚îú‚îÄ‚îÄ S01rsyslog
        ‚îú‚îÄ‚îÄ S02network
        ‚îú‚îÄ‚îÄ S20sshd
        ‚îú‚îÄ‚îÄ K01gdm


    SYSTEMD AND RUNLEVEL
    ----------------------

    Modern Linux distributions (Ubuntu 16+, RHEL 7+, Debian 8+, etc.) use systemd, which replaces SysVinit and runlevels with targets.

    Runlevel	    Equivalent systemd Target	            Command to Use
    0	            poweroff.target	                        systemctl isolate poweroff.target
    1	            rescue.target	                        systemctl isolate rescue.target
    3	            multi-user.target	                    systemctl isolate multi-user.target
    5	            graphical.target	                    systemctl isolate graphical.target
    6	            reboot.target	                        systemctl isolate reboot.target

    +---------------------------------------------------------------+
    |                   Linux Runlevels and systemd Targets         |
    +---------------------------------------------------------------+
    |                                                               |
    |  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê|
    |  ‚îÇ Runlevel   ‚îÇ SysV Description         ‚îÇ systemd Target    ‚îÇ|
    |  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§|
    |  ‚îÇ 0          ‚îÇ Halt / Poweroff          ‚îÇ poweroff.target   ‚îÇ|
    |  ‚îÇ 1          ‚îÇ Single-user / Rescue     ‚îÇ rescue.target     ‚îÇ|
    |  ‚îÇ 2          ‚îÇ Multi-user (no network)  ‚îÇ multi-user.target*‚îÇ|
    |  ‚îÇ 3          ‚îÇ Full multi-user (text)   ‚îÇ multi-user.target ‚îÇ|
    |  ‚îÇ 4          ‚îÇ Undefined / Custom use   ‚îÇ (custom target)   ‚îÇ|
    |  ‚îÇ 5          ‚îÇ Graphical mode (GUI)     ‚îÇ graphical.target  ‚îÇ|
    |  ‚îÇ 6          ‚îÇ Reboot                   ‚îÇ reboot.target     ‚îÇ|
    |  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò|
    |                                                               |
    |  * Some distros (e.g., Debian) use runlevel 2 for normal mode |
    |    with networking.                                           |
    +---------------------------------------------------------------+


#

ls -l /sbin/init                    // To find whether system uses systemd or not
lrwxrwxrwx 1 root root 20 Feb  6  2020 /sbin/init -> /lib/systemd/systemd


systemctl get-default               // To check the current target
graphical.target


ls -ltr /etc/systemd/system/default.target      // it shows the target file content
/etc/systemd/system/default.target -> /lib/systemd/system/graphical.target


systemctl set-default multi-user.target         // Change the target
Created symlink /etc/systemd/system/default.target -> lib/systemd/system/multi-user.target


#
    Note : Runlevels define what services the system runs at boot, systemd replaced them with targets, but the concept is still the same.

#

    FILE TYPES IN LINUX
    --------------------
    In Linux, everything is treated as a file, whether it‚Äôs a text document, a device, or even a directory.
    Each file has a type, which tells the system how to handle it.


#

    Main File Types
    Symbol	            Type	            Description
    -	                Regular file	    Normal files ‚Äî text, binary, executables, etc.
    d	                Directory	        A folder containing files or subdirectories.
    l	                Symbolic link	    A shortcut or reference to another file. (hardlink and softlink)
    c	                Character device	For devices that handle data character by character (e.g., keyboard, serial port).
    b	                Block device	    For devices that handle data in blocks (e.g., hard drives, RAM).
    s	                Socket	            Used for inter-process communication (e.g., networking).
    p	                Named pipe (FIFO)	Enables communication between processes. Allows connecting one process as an input to another, unidirectional.

#

    How to Identify File Types
    ---------------------------

1. Using ls -l

    The first character in the output indicates the file type:

ls -l


    Example output:

    -rw-r--r--  1 user user  1200 Oct 18  report.txt            ‚Üí regular file
    drwxr-xr-x  2 user user  4096 Oct 18  docs/                 ‚Üí directory
    lrwxrwxrwx  1 user user    11 Oct 18  link -> report.txt    ‚Üí symlink
    crw-rw----  1 root tty  4, 1 Oct 18  /dev/tty1              ‚Üí character device
    brw-rw----  1 root disk 8, 0 Oct 18  /dev/sda               ‚Üí block device
    srw-rw-rw-  1 root root    0 Oct 18  /run/docker.sock       ‚Üí socket
    prw-r--r--  1 user user    0 Oct 18  /tmp/testpipe          ‚Üí named pipe

2. Using file command

    The file command inspects the content and tells what kind of data a file holds:

file report.txt
    Output:
    report.txt: ASCII text


file /bin/ls
    Output:
    /bin/ls: ELF 64-bit LSB executable


#

    FILESYSTEM HIERARCHY
    =====================
    The Filesystem Hierarchy in Linux defines how files and directories are organized in the system.Everything starts from the root directory (/), and all other files and 
    folders branch out from it ‚Äî like a tree.

#


    Directory	    Detailed Description	                                                                                                    Example Commands
    /	            The root directory is the topmost level of the Linux filesystem. Every single file and directory originates from here.      ls /, df -h /, sudo du -sh /*
                    It acts as the parent for all other paths.

    /boot	        Holds boot-related files required to start the system, including the Linux kernel (vmlinuz), initramfs, and bootloader      ls /boot, cat /boot/grub/grub.cfg, uname -r
                    configuration files like GRUB. Without this directory, the OS cannot boot.

    /root	        The home directory for the root (superuser) account. It‚Äôs separate from /home for security and recovery reasons. Only       sudo -i, cd /root, ls -la /root
                    accessible by the root user.

    /home	        Contains personal directories for regular users. Each user gets a subdirectory (e.g., /home/alex) that holds personal       ls /home, cd ~, du -sh /home/*
                    files, settings, and documents.	

    /bin	        Contains essential user command binaries needed for basic system operation and maintenance (used by all users). These       ls /bin, /bin/ls, which cp
                    include commands like ls, cp, mv, and cat that are available even in single-user mode.

    /sbin	        Contains system administration binaries used by the root user for managing the system (e.g., fsck, ifconfig, reboot).       ls /sbin, which fsck, /sbin/reboot
                    These are not usually in a regular user‚Äôs PATH.	

    /lib, /lib64	Houses shared libraries (similar to Windows DLLs) and kernel modules needed by essential binaries in /bin and /sbin.        ls /lib, ldd /bin/ls
                    These libraries are critical for system startup and basic functionality.

    /proc	        A virtual filesystem dynamically generated by the kernel. It provides information about running processes, system           ls /proc, cat /proc/cpuinfo, cat /proc/meminfo, ps -ef
                    memory, CPU, and kernel parameters. Files like /proc/cpuinfo and /proc/meminfo expose real-time data.

    /sys	        A virtual filesystem that provides detailed information and configuration interfaces for kernel objects and devices         ls /sys, cat /sys/class/net/eth0/operstate
                    (via sysfs). Used to tune kernel parameters and view device states.	

    /dev	        Contains device files that represent physical or virtual hardware components like disks (/dev/sda), terminals (/dev/tty),   ls /dev, lsblk, `dmesg
                    and USB drives. Linux treats devices as files, allowing input/output through the filesystem.

    /media	        Used as a mount point for removable media like USB drives, CDs, and DVDs. When you insert removable media, the system       ls /media, mount, umount /media/usb
                    usually mounts it here automatically.

    /opt	        Contains optional or third-party application software packages. Vendors often install their products here to avoid          ls /opt, du -sh /opt/*
                    cluttering system directories (e.g., /opt/google/chrome).

    /mnt	        A temporary mount point for mounting external filesystems or storage devices manually by administrators. Commonly used      sudo mount /dev/sdb1 /mnt, ls /mnt, sudo umount /mnt
                    during maintenance or troubleshooting.	

    /etc	        Stores system-wide configuration files for the operating system and installed services. This includes network settings,     ls /etc, cat /etc/passwd, grep root /etc/group
                    user accounts, and daemon configurations (e.g., /etc/ssh/sshd_config, /etc/fstab).

    /run	        Stores runtime data like process IDs (PIDs), sockets, and temporary files used by system services after boot. The data in   ls /run, cat /run/utmp, systemctl status
                    /run is cleared at every reboot.

    /srv	        Holds service data directories for system services such as web servers (/srv/www) or FTP servers (/srv/ftp). Used for       ls /srv, du -sh /srv/*
                    storing data served by network services.

    /tmp	        Used to store temporary files created by users or applications. Data here is typically cleared at reboot. Accessible by     ls /tmp, touch /tmp/test.txt, rm /tmp/test.txt
                    all users but with restricted permissions.

    /usr	        Contains secondary user programs, libraries, documentation, and utilities not needed for system boot. Subdirectories        ls /usr, `ls /usr/bin
                    include /usr/bin, /usr/lib, and /usr/share.

    /var	        Contains variable data that changes frequently during system operation, such as logs, mail, print spools, and caches.       ls /var, ls /var/log, tail -f /var/log/syslog
                    Logs in /var/log are crucial for troubleshooting.


#

    Concept Diagram (Text Format)
    ------------------------------
        /
        ‚îú‚îÄ‚îÄ bin      ‚Üí essential user commands
        ‚îú‚îÄ‚îÄ sbin     ‚Üí essential system admin commands
        ‚îú‚îÄ‚îÄ etc      ‚Üí configuration files
        ‚îú‚îÄ‚îÄ lib      ‚Üí shared libraries
        ‚îú‚îÄ‚îÄ var      ‚Üí logs, mail, spool, temp data
        ‚îú‚îÄ‚îÄ usr      ‚Üí user programs, documentation
        ‚îú‚îÄ‚îÄ home     ‚Üí user home directories
        ‚îú‚îÄ‚îÄ boot     ‚Üí kernel, bootloader files
        ‚îú‚îÄ‚îÄ dev      ‚Üí device files
        ‚îú‚îÄ‚îÄ tmp      ‚Üí temporary files
        ‚îú‚îÄ‚îÄ proc     ‚Üí process and kernel info (virtual)
        ‚îî‚îÄ‚îÄ root     ‚Üí root user's home

#

    Quick Commands to Explore
    --------------------------
ls /
ls /bin
ls /etc
ls /usr/bin | head