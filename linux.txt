#
    BASICCOMMANDS

pwd

echo "Hello!" or echo Hello!

uptime

history             // To know history of commands that have been ran

#

    HELP SYSTEM IN Linux

                    // To know a short summary of what a command does.
    
whatis ls
ls (1)               - list directory contents

                    // To get help content of a command on screen

ls --help

                    // To open the man pages of commands

man ls

man echo            // use man command to know more about any command.

#

apropos man         // Each manual page has a short description available within it.  apropos searches the descriptions for instances of keyword.

#

    TYPE OF Commands

    ================================================================================================================
    Type	                Description
    Internal Commands	    Built into the shell (e.g. Bash), no separate executable file. Fast, always available.
    External Commands	    Stored as separate binaries (usually in /bin, /usr/bin). Run by calling the binary.

    Linux Internal vs External Commands â€“ Table
    --------------------------------------------
    Command	        Type	        Description	                    How to Check
    cd	            Internal	    Change directory	            type cd â†’ cd is a shell builtin
    echo	        Internal	    Print to terminal	            type echo
    pwd	            Internal	    Show current directory	        type pwd
    exit	        Internal	    Exit shell session	            type exit
    export	        Internal	    Set environment variable	    type export
    alias	        Internal	    Create command shortcuts	    type alias
    read	        Internal	    Read user input	                type read
    set	            Internal	    Set shell variables / options	type set
    umask	        Internal	    Set default permission mask	    type umask
    history	        Internal	    Show command history	        type history

    Command	        Type	        Description	                    Where It's Stored
    ls	            External	    List directory contents	        /bin/ls
    cp	            External	    Copy files/directories	        /bin/cp
    mv	            External	    Move/rename files	            /bin/mv
    rm	            External	    Remove files	                /bin/rm
    mkdir	        External	    Create directory	            /bin/mkdir
    ping	        External	    Send ICMP packets	            /bin/ping or /usr/bin/ping
    top	            External	    Show processes/resources	    /usr/bin/top
    ps	            External	    Process snapshot	            /bin/ps
    netstat	        External	    Show network connections	    /usr/bin/netstat
    find	        External	    Find files	                    /usr/bin/find
    grep	        External	    Search inside files	            /bin/grep
    df	            External	    Show disk space	                /bin/df
    tar	            External	    Archive files	                /bin/tar
    curl	        External	    Transfer data over network	    /usr/bin/curl
    systemctl	    External	    Manage system services (systemd)/bin/systemctl
    ================================================================================================================

#

    type echo #use type command to know whether a command is internal or External.

#

    mkdir directory     // To create a directory

mkdir -p directory1/{directory2,directory3} #To have folder structure as directory1/directory2 and directory1/directory3

#

    touch file          // To create a file

touch directory1/directory2/file.txt          // creates a file with name file.txt

#

    To view the folder structure of any directory

tree

ls -R

#

                        // Scroll and search within the file

        more

        [Space] - scrolls the display, one screensful of data at a time.
        [Enter] - scrolls the display one line.
        [b] - scrolls the display backwards one screenful of data.
        [/] - search text

more file.txt

        less
        [Up Arrow] - scrolls up the display one line.
        [Down Arrow] - scrolls down the display one line.
        [/] - search text

less file.txt

#

    SHELLS : A shell is a command-line interpreter. It takes the commands you type and passes them to the Linux kernel to execute.

    Main Types of Shells
    Shell	                            Path (usually)	        Description
    Bourne Shell (sh)	                /bin/sh	                The original Unix shell; basic and fast
    Bash (Bourne Again Shell)	        /bin/bash	            Most popular; default on many systems
    Zsh (Z Shell)	                    /bin/zsh	            Advanced features, customization, oh-my-zsh themes
    Korn Shell (ksh)	                /bin/ksh	            Combines features of sh and csh; used in enterprises
    C Shell (csh)	                    /bin/csh	            C-like syntax, mostly historical
    Fish (Friendly Interactive Shell)	/usr/bin/fish	        Modern, user-friendly with syntax highlighting


echo $SHELL                 // To know which shell is in use

chsh                        // To change the shell

alias dt=date               // Setting an alias for dat command

#

    ENVIRONMENT VARIABLES

env                         // To display all variables in the shell environment.

echo $SHELL                 // To display value stored in a single variable.
echo $LOGNAME

export OFFICE=Caleston      // To set value of a variable.
OFFICE=Caleston             // Variable value set only for the current session.

    ~/.profile
    or
    ~/.pam_environment      // To make the values of variables permanent over reboots, set them in the user profile.

#

    PATH VARIABLE
    When a user issues an external command into the shell, the shell uses a path variable to search for these external commands.

echo $PATH                  // To see the directories defined in the $PATH variable.
                            NOTE : If the path variable does not have the location of a command or a program defined, running a command by itself will result in a failure.

which obs-studio           // To check if the location of a command (obs-studio) can be identified.
export PATH=$PATH:/opt/obs/bin // To add the path of a command (obs-studio) in $PATH environment variable.
which obs-studio            // It should display the path [opt/obs/bin/obs-studio] as output.


#

    BASH PROMPT
    It shows the logged in user and host systems details, it is editable.

[user@hostname]$        // This can be like [michael@prod-server]$
                        // $ is a User Prompt Symbol

    The bash prompt is controlled by special shell environment variables, one common one is PS1.
    PS1 : Prompt definition, the variable that defines what your terminal prompt looks like in bash.

    ðŸ§± 1ï¸âƒ£ Basic printable characters

    You can use any normal text (letters, numbers, punctuation, emojis, etc.) directly in PS1.

    Example:
    PS1="Hello > "

    Produces:
    Hello >


    âœ… Allowed:

    Letters: a-z A-Z

    Numbers: 0-9

    Symbols: !@#$%^&*()[]{}<>?/|;:'",.=-+_

    Emojis and Unicode (âœ… e.g. PS1="ðŸ§ \u@\h \$ ")


    ðŸ§© 2ï¸âƒ£ Backslash escapes (special \ sequences)

    These are special placeholders Bash replaces dynamically.

    Hereâ€™s the full list (from the official Bash manual):

    Sequence	                        Meaning	                                            Example Output
    \a	                                ASCII bell (beep)	                                ðŸ”” sound
    \d	                                Date (e.g., "Sat Oct 18")	                        Sat Oct 18
    \D{format}	                        Custom date/time (strftime format)	                \D{%F %T} â†’ 2025-10-18 14:42:00
    \e	                                Escape character (useful for colors)	            â€”
    \h	                                Hostname (short)	                                debian
    \H	                                Full hostname	                                    debian.localdomain
    \j	                                Number of jobs currently managed by shell	        0
    \l	                                Terminal device name (basename of tty)	            pts/0
    \n	                                Newline	                                            (starts a new line)
    \r	                                Carriage return	                                    â€”
    \s	                                Shell name	                                        bash
    \t	                                Current time (HH:MM:SS)	                            14:42:36
    \T	                                Time (12-hour, with AM/PM)	                        02:42:36 PM
    \@	                                Time (12-hour with am/pm)	                        02:42 pm
    \A	                                Time (24-hour HH:MM)	                            14:42
    \u	                                Username	                                        alice
    \v	                                Bash version (short)	                            5.2
    \V	                                Bash version (long, e.g. 5.2.15)	                5.2.15
    \w	                                Current working directory	                        /home/alice/projects
    \W	                                Basename of \w (last part)	                        projects
    \!	                                History number of this command	                    132
    \#	                                Command number (since shell start)	                24
    \$	                                $ for user, # for root	                            $
    \nnn	                            Character with octal value nnn	                    e.g., \007 = BEL
    \\	                                A literal backslash	                                \
    \[	                                Start of non-printing sequence (for color codes)	â€”
    \]	                                End of non-printing sequence	                    â€”


    ðŸŽ¨ 3ï¸âƒ£ ANSI color codes and formatting

    You can include ANSI escape codes to add color and style.
    You must wrap them in \[ \] to tell Bash they donâ€™t take up screen space.

    Example	            Description
    \[\e[0m\]	        Reset all colors
    \[\e[31m\]	        Red text
    \[\e[32m\]	        Green text
    \[\e[33m\]	        Yellow text
    \[\e[34m\]	        Blue text
    \[\e[1m\]	        Bold
    \[\e[4m\]	        Underline

    Example:

    PS1="\[\e[1;32m\]\u@\h\[\e[0m\]:\[\e[1;34m\]\w\[\e[0m\]\$ "

    â†’ Shows green user@host, blue directory, and resets after.


    âš™ï¸ 4ï¸âƒ£ Variable and command substitutions

    You can embed shell variables or even commands in your prompt.

    ðŸ§® Variables:
    PS1="[$USER@$HOSTNAME] "


    â†’ [alice@debian]

    âš¡ Command substitution:
    PS1="\u@\h:\$(date +%H:%M)\$ "


    â†’ alice@debian:14:43$

    (Note: use \$() not backticks, and escape $ if needed.)


    ðŸ§  5ï¸âƒ£ Conditional or dynamic parts

    You can include Bash expressions like:

    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '


    â†’ Only prints ($debian_chroot) if that variable is set.


    âš ï¸ 6ï¸âƒ£ What NOT to do

    âŒ Donâ€™t forget to wrap non-printing sequences (color codes) with \[ \].

    Otherwise, line wrapping breaks.

    âŒ Donâ€™t use raw control characters (except through escapes).

    âŒ Avoid very long or slow command substitutions â€” theyâ€™ll make your prompt lag.


    âœ… 7ï¸âƒ£ Example: A fancy colored PS1

    PS1='\[\e[1;32m\]\u@\h\[\e[0m\]:\[\e[1;34m\]\w\[\e[0m\]\[\e[1;33m\] $(date +%H:%M:%S)\[\e[0m\]\$ '


    Might look like:

    alice@debian:/home/alice/projects 14:45:12$

    (with username green, path blue, time yellow)
#

echo $PS1
\[\]\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ \[\]

    
    1ï¸âƒ£ What is $PS1?

    $PS1 is the primary prompt string â€” it tells Bash what to display when waiting for a command.

    If $PS1 contains \u@\h:\w\$ , your prompt might look like:

user@hostname:/home/user$

    
    2ï¸âƒ£ Letâ€™s decode your PS1 step by step

SEGMENT 1: \[\]\[\e]0;\u@\h: \w\a\]

    \e = ESC (start of an escape sequence)

    ]0;... = set terminal window title

    \u = current username

    \h = hostname (first part before .)

    \w = current working directory

    \a = BEL character (ends the title-setting command)

    \[ and \] = mark â€œnon-printing charactersâ€ (so Bash can correctly handle cursor position and line wrapping)


    ðŸ§  So this portion sets your terminal title bar (not the visible prompt line).

    âœ… Example:
    If your user is alice, host is debian, and youâ€™re in /home/alice/projects,
    your terminal window title (the title bar, not the prompt) becomes:

    alice@debian: /home/alice/projects


SEGMENT 2: ${debian_chroot:+($debian_chroot)}

    ${var:+value} means: if $var is set and non-empty, substitute value; otherwise, substitute nothing.

    So:

    If you are inside a Debian chroot environment (e.g. /etc/debian_chroot exists), this shows something like (chrootname)

    Otherwise, nothing is displayed.

    âœ… Example:
    If $debian_chroot=â€œbusterâ€, this part becomes:

    (buster)


SEGMENT 3: \[\033[01;32m\]\u@\h\[\033[00m\]

    This sets colored text for username@hostname.

    \033 = ESC (same as \e)

    [01;32m = bright green text

    \u@\h = username@hostname

    [00m = reset color to default

    âœ… Example:
    Appears as:

    alice@debian

    (in green)


SEGMENT 4: :

    Just a literal colon separating the hostname from the working directory.


SEGMENT 5: \[\033[01;34m\]\w\[\033[00m\]

    Same color pattern:

    \033[01;34m = bright blue

    \w = current directory (full path, but with ~ for home)

    \033[00m = reset color

    âœ… Example:

    If you are in /home/alice/projects, this appears as:

    /home/alice/projects

    (in blue)


SEGMENT 6: \$

    \$ = prints # if you are root, $ if you are normal user

    = a space for readability

    âœ… Example:

    $

    (for regular user)
    or

    #

    (for root)


SEGMENT 7: \[\]

    These empty \[ \] pairs mark the end â€” they donâ€™t change anything; just delimit non-printing characters.

    âœ… Final Output Example

    If:

    user = alice

    host = debian

    directory = /home/alice/projects

    not in chroot

    normal user

    Youâ€™ll see:

    alice@debian:/home/alice/projects$ 


    With:

    alice@debian in green

    /home/alice/projects in blue

    $ in default color

    Terminal window title set to â€œalice@debian: /home/alice/projectsâ€


ðŸŽ¨ Summary Table
==================

Code	                            Meaning	                            Example Output
\u	                                Username	                        alice
\h	                                Hostname	                        debian
\w	                                Working directory	                /home/alice/projects
\e / \033	                        Escape character for ANSI codes	    â€”
[01;32m	                            Bright green text	                â€”
[01;34m	                            Bright blue text	                â€”
[00m	                            Reset color	                        â€”
\$	                                $ (user) or # (root)	            $
${debian_chroot:+($debian_chroot)}	Show chroot name if set	            (buster)
\[ \]	                            Mark non-printing sequences	        â€”


#

    LINUX KERNEL
    It is a major component of an operating system and is the core interface between a computer's hardware and its processes.

    +-------------------------------------------------------+
    |                    User Space                         |
    |-------------------------------------------------------|
    |  Applications / User Programs                         |
    |  (e.g., Browser, Editor, Games, etc.)                 |
    |                                                       |
    |  -> Interact with the kernel via System Calls (API)   |
    +-------------------------------------------------------+
                            |
                            |  System Calls / Interrupts
                            v
    +-------------------------------------------------------+
    |                    Kernel Space                       |
    |-------------------------------------------------------|
    |  KERNEL = Core part of the Operating System           |
    |                                                       |
    |  - Process Management                                 |
    |  - Memory Management                                  |
    |  - Device Drivers                                     |
    |  - File System Management                             |
    |  - Networking Stack                                   |
    |                                                       |
    |  -> Mediates access between software and hardware     |
    +-------------------------------------------------------+
                            |
                            |  Hardware Abstraction Layer
                            v
    +-------------------------------------------------------+
    |                     Hardware                          |
    |-------------------------------------------------------|
    |  CPU | Memory | Disk | Devices | Network Interfaces   |
    +-------------------------------------------------------+

#

    What the Kernel Does
    ======================

    Here are its main jobs (in plain language):

    Manages memory â€“ decides how RAM is used and shared among apps.

    Controls processes â€“ starts, stops, and schedules programs (CPU scheduling).

    Handles hardware â€“ communicates with the CPU, disks, keyboard, etc., through device drivers.

    Manages system calls â€“ lets apps safely ask the OS to do things (like read a file or send data).

#

    How It Works (Step-by-step Example)
    =====================================

    Letâ€™s say you click â€œSaveâ€ in a text editor.

    App (user program) says:

    â€œHey OS, please save this file!â€

    Library translates that request into a system call.

    Kernel takes over:

    Finds space on the disk,

    Writes the data,

    Updates the file system.

    Hardware (disk) does the actual writing.

    So the kernel makes sure everything happens safely and correctly â€” no app directly touches hardware.

                    +-------------------------+
                    |      User Programs      |
                    +-----------+-------------+
                                |
                                |  System Calls (Requests)
                                v
    +------------------------------------------------------+
    |                      KERNEL                          |
    |------------------------------------------------------|
    |  Process Control   â†’ creates, runs, and stops tasks   |
    |  Memory Manager    â†’ gives programs RAM safely        |
    |  File System       â†’ reads/writes files               |
    |  Device Drivers    â†’ talks to hardware                |
    |  Networking        â†’ handles data over network        |
    +------------------------------------------------------+
                                |
                                |  Hardware Instructions
                                v
    +------------------------------------------------------+
    |                     HARDWARE                         |
    |     CPU | Memory | Disk | Network | Devices          |
    +------------------------------------------------------+


#

    Two â€œWorldsâ€ Inside Your Computer
    ==================================

    The CPU runs in two main modes:

    +--------------------+
    | User Mode          | â†’ Apps run here
    | Limited Access     |
    | Needs permission   |
    +--------------------+
            |
            | System Call (Switch)
            v
    +--------------------+
    | Kernel Mode        | â†’ Kernel runs here
    | Full access to HW  |
    | Manages resources  |
    +--------------------+

#

    +-------------------------------------------------------+
    |                     User Space                        |
    |-------------------------------------------------------|
    |  Web Browser, Bash, Docker, kubelet, nginx, sshd      |
    |  â””â”€> Use system calls to ask kernel for resources     |
    +-------------------------------------------------------+
                        â†“   â†‘  (system calls, interrupts)
    +-------------------------------------------------------+
    |                     Kernel Space                      |
    |-------------------------------------------------------|
    |  Memory Manager, Process Scheduler, File Systems      |
    |  Network Stack, Device Drivers, Security Modules      |
    +-------------------------------------------------------+
                        â†“
    +-------------------------------------------------------+
    |                     Hardware                          |
    |-------------------------------------------------------|
    |  CPU, RAM, Disk, NIC, GPU, Devices                    |
    +-------------------------------------------------------+



    This separation keeps the system stable and secure â€”
    if an app crashes, it doesnâ€™t crash the whole system.

#

    User Space
    ===========

    These are programs and services that run in the normal, restricted mode.

    Category	                        Examples	                                Notes
    User Applications	                Chrome, VS Code, Firefox, Slack	            Directly used by users
    System Utilities	                ls, cat, top, systemctl	                    Run commands and tools
    Background Services (daemons)	    sshd, nginx, containerd, dockerd	        Managed by the OS but run in user space
    Kubernetes Processes	            kubelet, kube-proxy, kube-apiserver, etcd	All these are user-space binaries that rely on the kernel to do real work
    Shells	                            bash, zsh, fish	                            Where you type commands
    User Libraries	                    libc, OpenSSL, glibc	                    Provide system call interfaces to the kernel

    Key point:
    -----------
    User-space programs request services from the kernel using system calls â€” e.g., read files, open sockets, allocate memory.

#

    Kernel Space
    =============

    This is where core operating system components and device drivers live.

    Category	                        Examples	                                                Notes
    Core Kernel	                        Linux kernel itself (vmlinux)	                            Manages hardware, memory, CPU
    Device Drivers	                    e1000e (Ethernet), nvme, usb-storage	                    Control physical devices
    File Systems	                    ext4, xfs, btrfs, overlayfs	                                Handle file operations
    Network Stack	                    netfilter, iptables, TCP/IP	                                Handles all network traffic
    Process Scheduler	                Schedules CPU time for processes	                        Determines which process runs next
    Memory Manager	                    Handles virtual memory, paging, caching	                    Ensures isolation between processes
    Interrupt Handlers	                Handle hardware events (e.g., keyboard input, NIC packets)	Executed by kernel directly

    Key point:
    -----------
    Kernel code runs with high privileges â€” a crash here can bring down the entire system.


#

    Summary
    Aspect	                User Space	                    Kernel Space
    Privilege Level	        Low (restricted)	            High (full access)
    Crashes Affect	        Only that process	            Entire system
    Runs What	            Apps, daemons, system tools	    Kernel, drivers, schedulers
    Example Processes	    bash, nginx, kubelet	        ksoftirqd, systemd-udevd, ext4, netfilter
    Interface	            System calls (API)	            Hardware interrupts, syscalls handler

#

    KERNEL VERSIONS
    ================


uname                       // To display information about the kernel.

uname -r                    // To print the kernel version.


6.6.87.2-microsoft-standard-WSL2


    â”Œâ”€â”€â”¬â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚6 â”‚6 â”‚87  â”‚2 â”‚ -microsoft-standard-WSL2     â”‚
    â””â”€â”€â”´â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚  â”‚   â”‚   â”‚             â”‚
    â”‚  â”‚   â”‚   â”‚             â””â”€â–º Distro/Build Tag (WSL2 build by Microsoft)
    â”‚  â”‚   â”‚   â””â”€â–º Optional local patch or revision (non-standard)
    â”‚  â”‚   â””â”€â”€â”€â”€â”€â–º Patch version (bug fixes)
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Minor version (feature updates)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º **Major version**


    Kernel: 6.6.87.2-microsoft-standard-WSL2

#

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Major (6)  â”‚ Minor (6)  â”‚ Patch (87) â”‚ Rev (2)    â”‚ Build Tag (WSL2)           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

#

    Correct interpretation:
    Part	                    Meaning	                        Example	                    Notes
    6	                        Major version	                6	                        Big architectural release (Kernel 6.x series)
    6	                        Minor version	                6	                        Adds new features, updates, and subsystem changes
    87	                        Patch level	                    87	                        Bug and stability fixes
    2	                        Local patch or rebuild revision	2	                        Used internally by distro maintainers (here, Microsoftâ€™s WSL2 team)
    -microsoft-standard-WSL2	Distro tag	                    -microsoft-standard-WSL2	Identifies this kernel as a custom Microsoft build for WSL2

#

    Why it looks confusing
    ------------------------

    Historically:

    Before 2003, Linux used a three-number scheme (2.6.32 â†’ major.minor.patch).

    Now itâ€™s two main numbers (major.minor), and the rest are patch/build identifiers.

    So for:
    
    6.6.87.2


    you can think of it as:
    Kernel 6 (major) â†’ Minor 6 â†’ Patch 87 â†’ Local revision 2

#

    How WSL2 adds extra info
    -------------------------

    Microsoft compiles its own Linux kernel for WSL2, and appends:

    -microsoft-standard-WSL2


    Thatâ€™s not part of the Linux versioning scheme â€” it just tells you this kernel was built and tuned for Windows Subsystem for Linux 2.

#

    EXAMPLE - Connecting a USB drive to PC
    ---------------------------------------

STEP 1: Physical Connection (Hardware Layer)

    - You insert the USB stick into the port.

    Hardware
    â””â”€â”€ USB Connector â†’ USB Controller (chip on motherboard)


    - The USB controller detects a new electrical signal â€”

    it notifies the CPU that a new USB device is connected via a hardware interrupt.


 STEP 2: Kernel Interrupt Handling (Kernel Space)

    - When the hardware interrupt fires:

    The CPU switches into kernel mode.

    The USB subsystem in the Linux kernel gets the signal.

    The kernel loads or activates the correct USB driver.

    Example kernel modules involved:

    usbcore.ko        â† Core USB support
    xhci_hcd.ko       â† USB 3.0 controller driver
    usb_storage.ko    â† Generic USB mass storage driver
    sd_mod.ko         â† SCSI disk module (for storage devices)


    - The kernel now treats the USB stick like a block device and assigns it a name like /dev/sdb.


 STEP 3: Device Initialization (Kernel Space)

    The kernel:

    Reads the USB device descriptor (metadata about the device).

    Allocates resources (buffers, endpoints).

    Registers the new device in /sys (sysfs) and /dev.

    You can see this with:

dmesg | tail                    // To display messages from an area of the kernel called the ring buffer, it contains hardware logs created durting kernel loading.
dmesg | grep -i usb

    Youâ€™ll get logs like:

    [1234.567890] usb 2-1: new high-speed USB device number 4 using xhci_hcd
    [1234.678901] usb 2-1: New USB device found, idVendor=0781, idProduct=5567
    [1234.789012] scsi 6:0:0:0: Direct-Access     SanDisk  Ultra 16GB 1.00 PQ: 0 ANSI: 6
    [1234.890123] sd 6:0:0:0: [sdb] 30535680 512-byte logical blocks


    - At this point, the kernel fully recognizes the USB stick and exposes it to user space as /dev/sdb.

 STEP 4: User Space Detection

    - In user space, background services like udev or systemd-udevd detect the new device event from the kernel.

    They:

    Create a device file in /dev/ (like /dev/sdb1).

    May automatically mount it (on desktop systems) using tools like udisks2 or gvfs.

    You can see it:

lsblk


    Output:

    sdb     8:16   1  14.5G  0 disk 
    â””â”€sdb1  8:17   1  14.5G  0 part  /media/user/USB


 STEP 5: Mounting (User Space + Kernel Space)

    When you or the system mounts the drive:

    sudo mount /dev/sdb1 /media/usb


    Hereâ€™s what happens:

    User space command mount (binary) runs.

    It makes a system call to the kernelâ€™s VFS (Virtual File System) layer.

    The kernel loads the correct filesystem driver (e.g., vfat.ko, exfat.ko, ntfs.ko).

    The kernel reads the filesystem metadata and connects it to /media/usb.

    Now the drive is accessible.


STEP 6: Using the Drive (User Space â†” Kernel Space)

    When you open or copy a file:

    User-space apps (cp, cat, file explorer) request reads/writes via system calls (read(), write()).

    The kernel filesystem layer translates those requests into block I/O.

    The USB storage driver sends data over the USB bus to/from the drive.

    User Space
    â†“
    System Calls (read/write)
    â†“
    Kernel Space
    â”œâ”€â”€ VFS â†’ Filesystem driver (FAT, NTFS)
    â”œâ”€â”€ Block layer
    â”œâ”€â”€ USB storage driver
    â†“
    Hardware (USB Controller â†” USB Drive)


STEP 7: Safely Removing the Drive

    When you click â€œEjectâ€ or run:

sudo umount /media/usb


    User-space command umount calls kernelâ€™s VFS to unmount.

    The kernel:

    Flushes any cached data to disk,

    Releases file handles,

    Notifies the USB driver subsystem.

    Once idle, the USB driver signals the controller â€” safe to remove.


#

    UDEV
    =====
    udev (userspace /dev) is the device manager for the Linux kernel, operating in user space. It handles the dynamic creation and removal of device nodes in the /dev directory.

    Responsibilities of udev:
    --------------------------

    Creates/removes device files under /dev dynamically when hardware is added/removed.

    Applies permissions and ownership to devices.

    Creates symlinks (like /dev/disk/by-uuid/).

    Loads firmware if needed.

    Runs user-defined scripts or actions when a device is detected (via udev rules).

    
    Example use case:

    When you plug in a USB drive:

    Kernel detects it and emits a udev event.

    udev listens for these events and:

    Creates the device node (e.g., /dev/sdb).

    Applies rules (e.g., setting permissions, running a script).

    Optionally triggers auto-mount (if configured via other subsystems).


#

    UDEVADM
    ========
    udevadm is the administrative tool to interact with the udev daemon. Think of it as the command-line interface to inspect, control, and debug udev.

    Common udevadm commands:

    Command	                        Purpose
    udevadm info	                Query udev database for device information.
    udevadm trigger	                Manually trigger udev events.                       // Useful after modifying udev rules to test them without rebooting.
    udevadm settle	                Wait for all current events to finish.
    udevadm monitor	                Watch udev events in real-time. (Listens to kernel uevents)
    udevadm control	                Modify udev daemon behavior (e.g., reload rules).
    udevadm control --reload-rules  Reload udev rules


#

    Where are the udev rules?
    --------------------------

    System rules: /usr/lib/udev/rules.d/

    Admin/custom rules: /etc/udev/rules.d/

    Udev rules have filenames like 10-local.rules or 99-usb.rules and define match-action pairs.

#

    LSPCI
    ======
    lspci is a command-line tool in Linux used to list all PCI (Peripheral Component Interconnect) devices on your system.

    It's part of the "pciutils package" and provides details about hardware devices connected to the PCI bus such as such as graphics cards, network cards, USB controllers, sound cards, ethernet cards, RAID controllers, video cards, directly attached wireless adapters

    PCI -> Peripheral Component Interconnect


     What is the PCI bus?
     ---------------------

    The PCI bus is a hardware bus used for attaching peripheral devices to a computer's motherboard. Common on desktops, laptops, and servers.


     What does lspci do?
     --------------------

    It reads from:

    /sys/bus/pci/devices/

    /proc/bus/pci/

    And uses the PCI ID database to translate numeric IDs into human-readable names.


    Basic Usage:
    -------------

    Command             Description
    lspci               View all PCI devices
    lspci -v            Get detailed info (verbose)
    lspci -vv           Show even more details
    lspci -k            Show kernel driver in use
    lspci -mm           Show in machine-readable format
    lspci -n            Display numeric device/vendor IDs


$ lspci
00:00.0 Host bridge: Intel Corporation 8th Gen Core Processor Host Bridge
00:02.0 VGA compatible controller: Intel Corporation UHD Graphics 620
00:14.0 USB controller: Intel Corporation Sunrise Point-LP USB 3.0 xHCI Controller
00:1f.3 Audio device: Intel Corporation Sunrise Point-LP HD Audio

    Each line shows:

    Bus address (00:02.0)

    Device class (VGA compatible controller)

    Vendor & model (Intel Corporation UHD Graphics 620)


    PCI ID Database
    ---------------

    To show readable vendor/device names, lspci uses:

    /usr/share/misc/pci.ids or /usr/share/hwdata/pci.ids

    You can update it with:

#

    LSBLK
    ======
    lsblk (List Block Devices) is a command-line utility in Linux used to list information about block devices â€” like hard drives, SSDs, USB drives, partitions, and loop devices.

    It's part of the "util-linux" package and is commonly used for inspecting storage devices and their structure.

    Basic Usage

lsblk

    Example output:

NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda      8:0    0  500G  0 disk 
â”œâ”€sda1   8:1    0  100G  0 part /
â”œâ”€sda2   8:2    0  300G  0 part /home
â””â”€sda3   8:3    0  100G  0 part [SWAP]

    Here:

    sda is a disk

    sda1, sda2, sda3 are partitions

    Mounted at /, /home, and swap

    Common Options
    Command	            Description
    lsblk -f	        Show filesystem info (type, UUID, label)
    lsblk -a	        List all devices (including empty ones)
    lsblk -d	        Only show top-level disks (not partitions)
    lsblk -e 7	        Exclude loop devices (major number 7)
    lsblk -o            NAME,SIZE,FSTYPE,MOUNTPOINT	Customize columns
    lsblk -J	        JSON output (useful for scripts)


    Bonus Tip: Combine with blkid

    lsblk is great for hierarchy and mount info.

    blkid shows detailed filesystem metadata (UUIDs, labels, types).

#

    MAJOR-MINOR NUMBER and DEVICE TYPE
    =============================

    What is a Major Number?

    The Major Number in Linux identifies the driver associated with a device.

    When the kernel sees a device, it uses the major number to know which kernel module (driver) should handle that device.

    Example:

$ ls -l /dev/sda
brw-rw---- 1 root disk **8, 0** Oct 18 10:00 /dev/sda

    b â†’ Block device
    8 â†’ Major number â†’ Identifies the disk driver (sd for SCSI disks)
    0 â†’ Minor number â†’ Identifies the specific device (e.g., partition or disk)


    Major vs Minor Number
    ----------------------

    Number Type	            Meaning
    Major	                Identifies the device driver
    Minor	                Identifies the specific instance of the device the driver controls


    Common Major Numbers
    ---------------------
    Major Number	        Device Type
    8	                    SCSI/SATA disks (sd)
    1	                    RAM disk (/dev/ram*)
    3	                    IDE hard drives (hd)
    7	                    Loop devices (/dev/loop*)
    180	                    USB devices
    202	                    Xen virtual block device
    254	                    Device mapper (e.g., LVM)

    You can see a full list in /proc/devices:
    cat /proc/devices


#

    What is a Device Type?
    =======================

    Device types tell Linux how to interact with the device:

    Type	            Description
    b	                Block device â€“ reads/writes data in blocks (e.g., disks, USB drives)
    c	                Character device â€“ reads/writes data as a stream (e.g., keyboards, serial ports)
    p	                FIFO/pipe â€“ for inter-process communication


    Example:

$ ls -l /dev/tty0
crw--w---- 1 root tty 4, 0 Oct 18 10:00 /dev/tty0

c â†’ Character device
4 â†’ Major (TTY driver)
0 â†’ Minor


#

    LSCPU
    ======
    lscpu is a Linux command-line utility that displays CPU architecture information.
    It's a quick way to inspect details about the systemâ€™s processor(s) â€” such as cores, threads, sockets, CPU family, virtualization support, and more.

    It pulls information from /proc/cpuinfo and sysfs.


    What does lscpu show?
    -----------------------

    Hereâ€™s a sample output:
    Architecture:            x86_64
    CPU op-mode(s):          32-bit, 64-bit
    Byte Order:              Little Endian
    CPU(s):                  8
    On-line CPU(s) list:     0-7
    Thread(s) per core:      2
    Core(s) per socket:      4
    Socket(s):               1
    Vendor ID:               GenuineIntel
    Model name:              Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz
    Virtualization:          VT-x
    L1d cache:               32K
    L2 cache:                256K
    L3 cache:                8192K


    Key Fields Explained:

    Field	                Meaning
    Architecture	        CPU architecture (e.g., x86_64, aarch64)
    CPU(s)	                Total number of logical processors (threads)
    Thread(s) per core	    Indicates hyperthreading (2 = enabled)
    Core(s) per socket	    Physical cores per CPU
    Socket(s)	            Number of physical CPUs (usually 1 in laptops/desktops)
    Model name	            CPU branding info
    Virtualization	        Whether virtualization is supported (e.g., VT-x, AMD-V)
    Caches	                Sizes of L1, L2, L3 CPU caches


    Example Use Cases
    
    Command                 Description
    lscpu                   Show CPU layout
    lscpu -J                Display info in JSON format
    lscpu --parse=NUMA      Show NUMA info (if applicable)
    lscpu | grep '^CPU(s)'  Show only specific fields


#

    Difference vs /proc/cpuinfo
    ----------------------------

lscpu:              Structured, high-level summary (uses sysfs)

/proc/cpuinfo:      Raw per-CPU core details (e.g., flags, bugs)

Use cat /proc/cpuinfo if you need flags like sse4_2, vmx, aes, etc.


