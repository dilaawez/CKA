#
    BASICCOMMANDS

pwd

echo "Hello!" or echo Hello!

uptime

history             // To know history of commands that have been ran

#

    HELP SYSTEM IN Linux

                    // To know a short summary of what a command does.
    
whatis ls
ls (1)               - list directory contents

                    // To get help content of a command on screen

ls --help

                    // To open the man pages of commands

man ls

man echo            // use man command to know more about any command.

#

apropos man         // Each manual page has a short description available within it.  apropos searches the descriptions for instances of keyword.

#

    TYPE OF Commands

    ================================================================================================================
    Type	                Description
    Internal Commands	    Built into the shell (e.g. Bash), no separate executable file. Fast, always available.
    External Commands	    Stored as separate binaries (usually in /bin, /usr/bin). Run by calling the binary.

    Linux Internal vs External Commands ‚Äì Table
    --------------------------------------------
    Command	        Type	        Description	                    How to Check
    cd	            Internal	    Change directory	            type cd ‚Üí cd is a shell builtin
    echo	        Internal	    Print to terminal	            type echo
    pwd	            Internal	    Show current directory	        type pwd
    exit	        Internal	    Exit shell session	            type exit
    export	        Internal	    Set environment variable	    type export
    alias	        Internal	    Create command shortcuts	    type alias
    read	        Internal	    Read user input	                type read
    set	            Internal	    Set shell variables / options	type set
    umask	        Internal	    Set default permission mask	    type umask
    history	        Internal	    Show command history	        type history

    Command	        Type	        Description	                    Where It's Stored
    ls	            External	    List directory contents	        /bin/ls
    cp	            External	    Copy files/directories	        /bin/cp
    mv	            External	    Move/rename files	            /bin/mv
    rm	            External	    Remove files	                /bin/rm
    mkdir	        External	    Create directory	            /bin/mkdir
    ping	        External	    Send ICMP packets	            /bin/ping or /usr/bin/ping
    top	            External	    Show processes/resources	    /usr/bin/top
    ps	            External	    Process snapshot	            /bin/ps
    netstat	        External	    Show network connections	    /usr/bin/netstat
    find	        External	    Find files	                    /usr/bin/find
    grep	        External	    Search inside files	            /bin/grep
    df	            External	    Show disk space	                /bin/df
    tar	            External	    Archive files	                /bin/tar
    curl	        External	    Transfer data over network	    /usr/bin/curl
    systemctl	    External	    Manage system services (systemd)/bin/systemctl
    ================================================================================================================

#

    type echo #use type command to know whether a command is internal or External.

#

    mkdir directory     // To create a directory

mkdir -p directory1/{directory2,directory3} #To have folder structure as directory1/directory2 and directory1/directory3

#

    touch file          // To create a file

touch directory1/directory2/file.txt          // creates a file with name file.txt

#

    To view the folder structure of any directory

tree

ls -R

#

                        // Scroll and search within the file

        more

        [Space] - scrolls the display, one screensful of data at a time.
        [Enter] - scrolls the display one line.
        [b] - scrolls the display backwards one screenful of data.
        [/] - search text

more file.txt

        less
        [Up Arrow] - scrolls up the display one line.
        [Down Arrow] - scrolls down the display one line.
        [/] - search text

less file.txt

#

    SHELLS : A shell is a command-line interpreter. It takes the commands you type and passes them to the Linux kernel to execute.

    Main Types of Shells
    Shell	                            Path (usually)	        Description
    Bourne Shell (sh)	                /bin/sh	                The original Unix shell; basic and fast
    Bash (Bourne Again Shell)	        /bin/bash	            Most popular; default on many systems
    Zsh (Z Shell)	                    /bin/zsh	            Advanced features, customization, oh-my-zsh themes
    Korn Shell (ksh)	                /bin/ksh	            Combines features of sh and csh; used in enterprises
    C Shell (csh)	                    /bin/csh	            C-like syntax, mostly historical
    Fish (Friendly Interactive Shell)	/usr/bin/fish	        Modern, user-friendly with syntax highlighting


echo $SHELL                 // To know which shell is in use

chsh                        // To change the shell

alias dt=date               // Setting an alias for dat command

#

    ENVIRONMENT VARIABLES

env                         // To display all variables in the shell environment.

echo $SHELL                 // To display value stored in a single variable.
echo $LOGNAME

export OFFICE=Caleston      // To set value of a variable.
OFFICE=Caleston             // Variable value set only for the current session.

    ~/.profile
    or
    ~/.pam_environment      // To make the values of variables permanent over reboots, set them in the user profile.

#

    PATH VARIABLE
    When a user issues an external command into the shell, the shell uses a path variable to search for these external commands.

echo $PATH                  // To see the directories defined in the $PATH variable.
                            NOTE : If the path variable does not have the location of a command or a program defined, running a command by itself will result in a failure.

which obs-studio           // To check if the location of a command (obs-studio) can be identified.
export PATH=$PATH:/opt/obs/bin // To add the path of a command (obs-studio) in $PATH environment variable.
which obs-studio            // It should display the path [opt/obs/bin/obs-studio] as output.


#

    BASH PROMPT
    It shows the logged in user and host systems details, it is editable.

[user@hostname]$        // This can be like [michael@prod-server]$
                        // $ is a User Prompt Symbol

    The bash prompt is controlled by special shell environment variables, one common one is PS1.
    PS1 : Prompt definition, the variable that defines what your terminal prompt looks like in bash.

    üß± 1Ô∏è‚É£ Basic printable characters

    You can use any normal text (letters, numbers, punctuation, emojis, etc.) directly in PS1.

    Example:
    PS1="Hello > "

    Produces:
    Hello >


    ‚úÖ Allowed:

    Letters: a-z A-Z

    Numbers: 0-9

    Symbols: !@#$%^&*()[]{}<>?/|;:'",.=-+_

    Emojis and Unicode (‚úÖ e.g. PS1="üêß \u@\h \$ ")


    üß© 2Ô∏è‚É£ Backslash escapes (special \ sequences)

    These are special placeholders Bash replaces dynamically.

    Here‚Äôs the full list (from the official Bash manual):

    Sequence	                        Meaning	                                            Example Output
    \a	                                ASCII bell (beep)	                                üîî sound
    \d	                                Date (e.g., "Sat Oct 18")	                        Sat Oct 18
    \D{format}	                        Custom date/time (strftime format)	                \D{%F %T} ‚Üí 2025-10-18 14:42:00
    \e	                                Escape character (useful for colors)	            ‚Äî
    \h	                                Hostname (short)	                                debian
    \H	                                Full hostname	                                    debian.localdomain
    \j	                                Number of jobs currently managed by shell	        0
    \l	                                Terminal device name (basename of tty)	            pts/0
    \n	                                Newline	                                            (starts a new line)
    \r	                                Carriage return	                                    ‚Äî
    \s	                                Shell name	                                        bash
    \t	                                Current time (HH:MM:SS)	                            14:42:36
    \T	                                Time (12-hour, with AM/PM)	                        02:42:36 PM
    \@	                                Time (12-hour with am/pm)	                        02:42 pm
    \A	                                Time (24-hour HH:MM)	                            14:42
    \u	                                Username	                                        alice
    \v	                                Bash version (short)	                            5.2
    \V	                                Bash version (long, e.g. 5.2.15)	                5.2.15
    \w	                                Current working directory	                        /home/alice/projects
    \W	                                Basename of \w (last part)	                        projects
    \!	                                History number of this command	                    132
    \#	                                Command number (since shell start)	                24
    \$	                                $ for user, # for root	                            $
    \nnn	                            Character with octal value nnn	                    e.g., \007 = BEL
    \\	                                A literal backslash	                                \
    \[	                                Start of non-printing sequence (for color codes)	‚Äî
    \]	                                End of non-printing sequence	                    ‚Äî


    üé® 3Ô∏è‚É£ ANSI color codes and formatting

    You can include ANSI escape codes to add color and style.
    You must wrap them in \[ \] to tell Bash they don‚Äôt take up screen space.

    Example	            Description
    \[\e[0m\]	        Reset all colors
    \[\e[31m\]	        Red text
    \[\e[32m\]	        Green text
    \[\e[33m\]	        Yellow text
    \[\e[34m\]	        Blue text
    \[\e[1m\]	        Bold
    \[\e[4m\]	        Underline

    Example:

    PS1="\[\e[1;32m\]\u@\h\[\e[0m\]:\[\e[1;34m\]\w\[\e[0m\]\$ "

    ‚Üí Shows green user@host, blue directory, and resets after.


    ‚öôÔ∏è 4Ô∏è‚É£ Variable and command substitutions

    You can embed shell variables or even commands in your prompt.

    üßÆ Variables:
    PS1="[$USER@$HOSTNAME] "


    ‚Üí [alice@debian]

    ‚ö° Command substitution:
    PS1="\u@\h:\$(date +%H:%M)\$ "


    ‚Üí alice@debian:14:43$

    (Note: use \$() not backticks, and escape $ if needed.)


    üß† 5Ô∏è‚É£ Conditional or dynamic parts

    You can include Bash expressions like:

    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '


    ‚Üí Only prints ($debian_chroot) if that variable is set.


    ‚ö†Ô∏è 6Ô∏è‚É£ What NOT to do

    ‚ùå Don‚Äôt forget to wrap non-printing sequences (color codes) with \[ \].

    Otherwise, line wrapping breaks.

    ‚ùå Don‚Äôt use raw control characters (except through escapes).

    ‚ùå Avoid very long or slow command substitutions ‚Äî they‚Äôll make your prompt lag.


    ‚úÖ 7Ô∏è‚É£ Example: A fancy colored PS1

    PS1='\[\e[1;32m\]\u@\h\[\e[0m\]:\[\e[1;34m\]\w\[\e[0m\]\[\e[1;33m\] $(date +%H:%M:%S)\[\e[0m\]\$ '


    Might look like:

    alice@debian:/home/alice/projects 14:45:12$

    (with username green, path blue, time yellow)
#

echo $PS1
\[\]\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ \[\]

    
    1Ô∏è‚É£ What is $PS1?

    $PS1 is the primary prompt string ‚Äî it tells Bash what to display when waiting for a command.

    If $PS1 contains \u@\h:\w\$ , your prompt might look like:

user@hostname:/home/user$

    
    2Ô∏è‚É£ Let‚Äôs decode your PS1 step by step

SEGMENT 1: \[\]\[\e]0;\u@\h: \w\a\]

    \e = ESC (start of an escape sequence)

    ]0;... = set terminal window title

    \u = current username

    \h = hostname (first part before .)

    \w = current working directory

    \a = BEL character (ends the title-setting command)

    \[ and \] = mark ‚Äúnon-printing characters‚Äù (so Bash can correctly handle cursor position and line wrapping)


    üß† So this portion sets your terminal title bar (not the visible prompt line).

    ‚úÖ Example:
    If your user is alice, host is debian, and you‚Äôre in /home/alice/projects,
    your terminal window title (the title bar, not the prompt) becomes:

    alice@debian: /home/alice/projects


SEGMENT 2: ${debian_chroot:+($debian_chroot)}

    ${var:+value} means: if $var is set and non-empty, substitute value; otherwise, substitute nothing.

    So:

    If you are inside a Debian chroot environment (e.g. /etc/debian_chroot exists), this shows something like (chrootname)

    Otherwise, nothing is displayed.

    ‚úÖ Example:
    If $debian_chroot=‚Äúbuster‚Äù, this part becomes:

    (buster)


SEGMENT 3: \[\033[01;32m\]\u@\h\[\033[00m\]

    This sets colored text for username@hostname.

    \033 = ESC (same as \e)

    [01;32m = bright green text

    \u@\h = username@hostname

    [00m = reset color to default

    ‚úÖ Example:
    Appears as:

    alice@debian

    (in green)


SEGMENT 4: :

    Just a literal colon separating the hostname from the working directory.


SEGMENT 5: \[\033[01;34m\]\w\[\033[00m\]

    Same color pattern:

    \033[01;34m = bright blue

    \w = current directory (full path, but with ~ for home)

    \033[00m = reset color

    ‚úÖ Example:

    If you are in /home/alice/projects, this appears as:

    /home/alice/projects

    (in blue)


SEGMENT 6: \$

    \$ = prints # if you are root, $ if you are normal user

    = a space for readability

    ‚úÖ Example:

    $

    (for regular user)
    or

    #

    (for root)


SEGMENT 7: \[\]

    These empty \[ \] pairs mark the end ‚Äî they don‚Äôt change anything; just delimit non-printing characters.

    ‚úÖ Final Output Example

    If:

    user = alice

    host = debian

    directory = /home/alice/projects

    not in chroot

    normal user

    You‚Äôll see:

    alice@debian:/home/alice/projects$ 


    With:

    alice@debian in green

    /home/alice/projects in blue

    $ in default color

    Terminal window title set to ‚Äúalice@debian: /home/alice/projects‚Äù


üé® Summary Table
==================

Code	                            Meaning	                            Example Output
\u	                                Username	                        alice
\h	                                Hostname	                        debian
\w	                                Working directory	                /home/alice/projects
\e / \033	                        Escape character for ANSI codes	    ‚Äî
[01;32m	                            Bright green text	                ‚Äî
[01;34m	                            Bright blue text	                ‚Äî
[00m	                            Reset color	                        ‚Äî
\$	                                $ (user) or # (root)	            $
${debian_chroot:+($debian_chroot)}	Show chroot name if set	            (buster)
\[ \]	                            Mark non-printing sequences	        ‚Äî


#

    LINUX KERNEL
    It is a major component of an operating system and is the core interface between a computer's hardware and its processes.

    +-------------------------------------------------------+
    |                    User Space                         |
    |-------------------------------------------------------|
    |  Applications / User Programs                         |
    |  (e.g., Browser, Editor, Games, etc.)                 |
    |                                                       |
    |  -> Interact with the kernel via System Calls (API)   |
    +-------------------------------------------------------+
                            |
                            |  System Calls / Interrupts
                            v
    +-------------------------------------------------------+
    |                    Kernel Space                       |
    |-------------------------------------------------------|
    |  KERNEL = Core part of the Operating System           |
    |                                                       |
    |  - Process Management                                 |
    |  - Memory Management                                  |
    |  - Device Drivers                                     |
    |  - File System Management                             |
    |  - Networking Stack                                   |
    |                                                       |
    |  -> Mediates access between software and hardware     |
    +-------------------------------------------------------+
                            |
                            |  Hardware Abstraction Layer
                            v
    +-------------------------------------------------------+
    |                     Hardware                          |
    |-------------------------------------------------------|
    |  CPU | Memory | Disk | Devices | Network Interfaces   |
    +-------------------------------------------------------+

#

    What the Kernel Does
    ======================

    Here are its main jobs (in plain language):

    Manages memory ‚Äì decides how RAM is used and shared among apps.

    Controls processes ‚Äì starts, stops, and schedules programs (CPU scheduling).

    Handles hardware ‚Äì communicates with the CPU, disks, keyboard, etc., through device drivers.

    Manages system calls ‚Äì lets apps safely ask the OS to do things (like read a file or send data).

#

    How It Works (Step-by-step Example)
    =====================================

    Let‚Äôs say you click ‚ÄúSave‚Äù in a text editor.

    App (user program) says:

    ‚ÄúHey OS, please save this file!‚Äù

    Library translates that request into a system call.

    Kernel takes over:

    Finds space on the disk,

    Writes the data,

    Updates the file system.

    Hardware (disk) does the actual writing.

    So the kernel makes sure everything happens safely and correctly ‚Äî no app directly touches hardware.

                    +-------------------------+
                    |      User Programs      |
                    +-----------+-------------+
                                |
                                |  System Calls (Requests)
                                v
    +------------------------------------------------------+
    |                      KERNEL                          |
    |------------------------------------------------------|
    |  Process Control   ‚Üí creates, runs, and stops tasks   |
    |  Memory Manager    ‚Üí gives programs RAM safely        |
    |  File System       ‚Üí reads/writes files               |
    |  Device Drivers    ‚Üí talks to hardware                |
    |  Networking        ‚Üí handles data over network        |
    +------------------------------------------------------+
                                |
                                |  Hardware Instructions
                                v
    +------------------------------------------------------+
    |                     HARDWARE                         |
    |     CPU | Memory | Disk | Network | Devices          |
    +------------------------------------------------------+


#

    Two ‚ÄúWorlds‚Äù Inside Your Computer
    ==================================

    The CPU runs in two main modes:

    +--------------------+
    | User Mode          | ‚Üí Apps run here
    | Limited Access     |
    | Needs permission   |
    +--------------------+
            |
            | System Call (Switch)
            v
    +--------------------+
    | Kernel Mode        | ‚Üí Kernel runs here
    | Full access to HW  |
    | Manages resources  |
    +--------------------+

#

    +-------------------------------------------------------+
    |                     User Space                        |
    |-------------------------------------------------------|
    |  Web Browser, Bash, Docker, kubelet, nginx, sshd      |
    |  ‚îî‚îÄ> Use system calls to ask kernel for resources     |
    +-------------------------------------------------------+
                        ‚Üì   ‚Üë  (system calls, interrupts)
    +-------------------------------------------------------+
    |                     Kernel Space                      |
    |-------------------------------------------------------|
    |  Memory Manager, Process Scheduler, File Systems      |
    |  Network Stack, Device Drivers, Security Modules      |
    +-------------------------------------------------------+
                        ‚Üì
    +-------------------------------------------------------+
    |                     Hardware                          |
    |-------------------------------------------------------|
    |  CPU, RAM, Disk, NIC, GPU, Devices                    |
    +-------------------------------------------------------+



    This separation keeps the system stable and secure ‚Äî
    if an app crashes, it doesn‚Äôt crash the whole system.

#

    User Space
    ===========

    These are programs and services that run in the normal, restricted mode.

    Category	                        Examples	                                Notes
    User Applications	                Chrome, VS Code, Firefox, Slack	            Directly used by users
    System Utilities	                ls, cat, top, systemctl	                    Run commands and tools
    Background Services (daemons)	    sshd, nginx, containerd, dockerd	        Managed by the OS but run in user space
    Kubernetes Processes	            kubelet, kube-proxy, kube-apiserver, etcd	All these are user-space binaries that rely on the kernel to do real work
    Shells	                            bash, zsh, fish	                            Where you type commands
    User Libraries	                    libc, OpenSSL, glibc	                    Provide system call interfaces to the kernel

    Key point:
    -----------
    User-space programs request services from the kernel using system calls ‚Äî e.g., read files, open sockets, allocate memory.

#

    Kernel Space
    =============

    This is where core operating system components and device drivers live.

    Category	                        Examples	                                                Notes
    Core Kernel	                        Linux kernel itself (vmlinux)	                            Manages hardware, memory, CPU
    Device Drivers	                    e1000e (Ethernet), nvme, usb-storage	                    Control physical devices
    File Systems	                    ext4, xfs, btrfs, overlayfs	                                Handle file operations
    Network Stack	                    netfilter, iptables, TCP/IP	                                Handles all network traffic
    Process Scheduler	                Schedules CPU time for processes	                        Determines which process runs next
    Memory Manager	                    Handles virtual memory, paging, caching	                    Ensures isolation between processes
    Interrupt Handlers	                Handle hardware events (e.g., keyboard input, NIC packets)	Executed by kernel directly

    Key point:
    -----------
    Kernel code runs with high privileges ‚Äî a crash here can bring down the entire system.


#

    Summary
    Aspect	                User Space	                    Kernel Space
    Privilege Level	        Low (restricted)	            High (full access)
    Crashes Affect	        Only that process	            Entire system
    Runs What	            Apps, daemons, system tools	    Kernel, drivers, schedulers
    Example Processes	    bash, nginx, kubelet	        ksoftirqd, systemd-udevd, ext4, netfilter
    Interface	            System calls (API)	            Hardware interrupts, syscalls handler

#

    KERNEL VERSIONS
    ================


uname                       // To display information about the kernel.

uname -r                    // To print the kernel version.


6.6.87.2-microsoft-standard-WSL2


    ‚îå‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ6 ‚îÇ6 ‚îÇ87  ‚îÇ2 ‚îÇ -microsoft-standard-WSL2     ‚îÇ
    ‚îî‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ  ‚îÇ   ‚îÇ   ‚îÇ             ‚îÇ
    ‚îÇ  ‚îÇ   ‚îÇ   ‚îÇ             ‚îî‚îÄ‚ñ∫ Distro/Build Tag (WSL2 build by Microsoft)
    ‚îÇ  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚ñ∫ Optional local patch or revision (non-standard)
    ‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Patch version (bug fixes)
    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Minor version (feature updates)
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ **Major version**


    Kernel: 6.6.87.2-microsoft-standard-WSL2

#

    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Major (6)  ‚îÇ Minor (6)  ‚îÇ Patch (87) ‚îÇ Rev (2)    ‚îÇ Build Tag (WSL2)           ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

#

    Correct interpretation:
    Part	                    Meaning	                        Example	                    Notes
    6	                        Major version	                6	                        Big architectural release (Kernel 6.x series)
    6	                        Minor version	                6	                        Adds new features, updates, and subsystem changes
    87	                        Patch level	                    87	                        Bug and stability fixes
    2	                        Local patch or rebuild revision	2	                        Used internally by distro maintainers (here, Microsoft‚Äôs WSL2 team)
    -microsoft-standard-WSL2	Distro tag	                    -microsoft-standard-WSL2	Identifies this kernel as a custom Microsoft build for WSL2

#

    Why it looks confusing
    ------------------------

    Historically:

    Before 2003, Linux used a three-number scheme (2.6.32 ‚Üí major.minor.patch).

    Now it‚Äôs two main numbers (major.minor), and the rest are patch/build identifiers.

    So for:
    
    6.6.87.2


    you can think of it as:
    Kernel 6 (major) ‚Üí Minor 6 ‚Üí Patch 87 ‚Üí Local revision 2

#

    How WSL2 adds extra info
    -------------------------

    Microsoft compiles its own Linux kernel for WSL2, and appends:

    -microsoft-standard-WSL2


    That‚Äôs not part of the Linux versioning scheme ‚Äî it just tells you this kernel was built and tuned for Windows Subsystem for Linux 2.

#

    EXAMPLE - Connecting a USB drive to PC
    ---------------------------------------

STEP 1: Physical Connection (Hardware Layer)

    - You insert the USB stick into the port.

    Hardware
    ‚îî‚îÄ‚îÄ USB Connector ‚Üí USB Controller (chip on motherboard)


    - The USB controller detects a new electrical signal ‚Äî

    it notifies the CPU that a new USB device is connected via a hardware interrupt.


 STEP 2: Kernel Interrupt Handling (Kernel Space)

    - When the hardware interrupt fires:

    The CPU switches into kernel mode.

    The USB subsystem in the Linux kernel gets the signal.

    The kernel loads or activates the correct USB driver.

    Example kernel modules involved:

    usbcore.ko        ‚Üê Core USB support
    xhci_hcd.ko       ‚Üê USB 3.0 controller driver
    usb_storage.ko    ‚Üê Generic USB mass storage driver
    sd_mod.ko         ‚Üê SCSI disk module (for storage devices)


    - The kernel now treats the USB stick like a block device and assigns it a name like /dev/sdb.


 STEP 3: Device Initialization (Kernel Space)

    The kernel:

    Reads the USB device descriptor (metadata about the device).

    Allocates resources (buffers, endpoints).

    Registers the new device in /sys (sysfs) and /dev.

    You can see this with:

dmesg | tail                    // To display messages from an area of the kernel called the ring buffer, it contains hardware logs created durting kernel loading.
dmesg | grep -i usb

    You‚Äôll get logs like:

    [1234.567890] usb 2-1: new high-speed USB device number 4 using xhci_hcd
    [1234.678901] usb 2-1: New USB device found, idVendor=0781, idProduct=5567
    [1234.789012] scsi 6:0:0:0: Direct-Access     SanDisk  Ultra 16GB 1.00 PQ: 0 ANSI: 6
    [1234.890123] sd 6:0:0:0: [sdb] 30535680 512-byte logical blocks


    - At this point, the kernel fully recognizes the USB stick and exposes it to user space as /dev/sdb.

 STEP 4: User Space Detection

    - In user space, background services like udev or systemd-udevd detect the new device event from the kernel.

    They:

    Create a device file in /dev/ (like /dev/sdb1).

    May automatically mount it (on desktop systems) using tools like udisks2 or gvfs.

    You can see it:

lsblk


    Output:

    sdb     8:16   1  14.5G  0 disk 
    ‚îî‚îÄsdb1  8:17   1  14.5G  0 part  /media/user/USB


 STEP 5: Mounting (User Space + Kernel Space)

    When you or the system mounts the drive:

    sudo mount /dev/sdb1 /media/usb


    Here‚Äôs what happens:

    User space command mount (binary) runs.

    It makes a system call to the kernel‚Äôs VFS (Virtual File System) layer.

    The kernel loads the correct filesystem driver (e.g., vfat.ko, exfat.ko, ntfs.ko).

    The kernel reads the filesystem metadata and connects it to /media/usb.

    Now the drive is accessible.


STEP 6: Using the Drive (User Space ‚Üî Kernel Space)

    When you open or copy a file:

    User-space apps (cp, cat, file explorer) request reads/writes via system calls (read(), write()).

    The kernel filesystem layer translates those requests into block I/O.

    The USB storage driver sends data over the USB bus to/from the drive.

    User Space
    ‚Üì
    System Calls (read/write)
    ‚Üì
    Kernel Space
    ‚îú‚îÄ‚îÄ VFS ‚Üí Filesystem driver (FAT, NTFS)
    ‚îú‚îÄ‚îÄ Block layer
    ‚îú‚îÄ‚îÄ USB storage driver
    ‚Üì
    Hardware (USB Controller ‚Üî USB Drive)


STEP 7: Safely Removing the Drive

    When you click ‚ÄúEject‚Äù or run:

sudo umount /media/usb


    User-space command umount calls kernel‚Äôs VFS to unmount.

    The kernel:

    Flushes any cached data to disk,

    Releases file handles,

    Notifies the USB driver subsystem.

    Once idle, the USB driver signals the controller ‚Äî safe to remove.


#

    UDEV
    =====
    udev (userspace /dev) is the device manager for the Linux kernel, operating in user space. It handles the dynamic creation and removal of device nodes in the /dev directory.

    Responsibilities of udev:
    --------------------------

    Creates/removes device files under /dev dynamically when hardware is added/removed.

    Applies permissions and ownership to devices.

    Creates symlinks (like /dev/disk/by-uuid/).

    Loads firmware if needed.

    Runs user-defined scripts or actions when a device is detected (via udev rules).

    
    Example use case:

    When you plug in a USB drive:

    Kernel detects it and emits a udev event.

    udev listens for these events and:

    Creates the device node (e.g., /dev/sdb).

    Applies rules (e.g., setting permissions, running a script).

    Optionally triggers auto-mount (if configured via other subsystems).


#

    UDEVADM
    ========
    udevadm is the administrative tool to interact with the udev daemon. Think of it as the command-line interface to inspect, control, and debug udev.

    Common udevadm commands:

    Command	                        Purpose
    udevadm info	                Query udev database for device information.
    udevadm trigger	                Manually trigger udev events.                       // Useful after modifying udev rules to test them without rebooting.
    udevadm settle	                Wait for all current events to finish.
    udevadm monitor	                Watch udev events in real-time. (Listens to kernel uevents)
    udevadm control	                Modify udev daemon behavior (e.g., reload rules).
    udevadm control --reload-rules  Reload udev rules


#

    Where are the udev rules?
    --------------------------

    System rules: /usr/lib/udev/rules.d/

    Admin/custom rules: /etc/udev/rules.d/

    Udev rules have filenames like 10-local.rules or 99-usb.rules and define match-action pairs.

#

    LSPCI
    ======
    lspci is a command-line tool in Linux used to list all PCI (Peripheral Component Interconnect) devices on your system.

    It's part of the "pciutils package" and provides details about hardware devices connected to the PCI bus such as such as graphics cards, network cards, USB controllers, sound cards, ethernet cards, RAID controllers, video cards, directly attached wireless adapters

    PCI -> Peripheral Component Interconnect


     What is the PCI bus?
     ---------------------

    The PCI bus is a hardware bus used for attaching peripheral devices to a computer's motherboard. Common on desktops, laptops, and servers.


     What does lspci do?
     --------------------

    It reads from:

    /sys/bus/pci/devices/

    /proc/bus/pci/

    And uses the PCI ID database to translate numeric IDs into human-readable names.


    Basic Usage:
    -------------

    Command             Description
    lspci               View all PCI devices
    lspci -v            Get detailed info (verbose)
    lspci -vv           Show even more details
    lspci -k            Show kernel driver in use
    lspci -mm           Show in machine-readable format
    lspci -n            Display numeric device/vendor IDs


$ lspci
00:00.0 Host bridge: Intel Corporation 8th Gen Core Processor Host Bridge
00:02.0 VGA compatible controller: Intel Corporation UHD Graphics 620
00:14.0 USB controller: Intel Corporation Sunrise Point-LP USB 3.0 xHCI Controller
00:1f.3 Audio device: Intel Corporation Sunrise Point-LP HD Audio

    Each line shows:

    Bus address (00:02.0)

    Device class (VGA compatible controller)

    Vendor & model (Intel Corporation UHD Graphics 620)


    PCI ID Database
    ---------------

    To show readable vendor/device names, lspci uses:

    /usr/share/misc/pci.ids or /usr/share/hwdata/pci.ids

    You can update it with:

#

    LSBLK
    ======
    lsblk (List Block Devices) is a command-line utility in Linux used to list information about block devices ‚Äî like hard drives, SSDs, USB drives, partitions, and loop devices.

    It's part of the "util-linux" package and is commonly used for inspecting storage devices and their structure.

    Basic Usage

lsblk

    Example output:

NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda      8:0    0  500G  0 disk 
‚îú‚îÄsda1   8:1    0  100G  0 part /
‚îú‚îÄsda2   8:2    0  300G  0 part /home
‚îî‚îÄsda3   8:3    0  100G  0 part [SWAP]

    Here:

    sda is a disk

    sda1, sda2, sda3 are partitions

    Mounted at /, /home, and swap

    Common Options
    Command	            Description
    lsblk -f	        Show filesystem info (type, UUID, label)
    lsblk -a	        List all devices (including empty ones)
    lsblk -d	        Only show top-level disks (not partitions)
    lsblk -e 7	        Exclude loop devices (major number 7)
    lsblk -o            NAME,SIZE,FSTYPE,MOUNTPOINT	Customize columns
    lsblk -J	        JSON output (useful for scripts)


    Bonus Tip: Combine with blkid

    lsblk is great for hierarchy and mount info.
    blkid shows detailed filesystem metadata (UUIDs, labels, types).

#

    MAJOR-MINOR NUMBER and DEVICE TYPE
    =============================

    What is a Major Number?

    The Major Number in Linux identifies the driver associated with a device.

    When the kernel sees a device, it uses the major number to know which kernel module (driver) should handle that device.

    Example:

$ ls -l /dev/sda
brw-rw---- 1 root disk **8, 0** Oct 18 10:00 /dev/sda

    b ‚Üí Block device
    8 ‚Üí Major number ‚Üí Identifies the disk driver (sd for SCSI disks)
    0 ‚Üí Minor number ‚Üí Identifies the specific device (e.g., partition or disk)


    Major vs Minor Number
    ----------------------

    Number Type	            Meaning
    Major	                Identifies the device driver
    Minor	                Identifies the specific instance of the device the driver controls


    Common Major Numbers
    ---------------------
    Major Number	        Device Type
    8	                    SCSI/SATA disks (sd)
    1	                    RAM disk (/dev/ram*)
    3	                    IDE hard drives (hd)
    7	                    Loop devices (/dev/loop*)
    180	                    USB devices
    202	                    Xen virtual block device
    254	                    Device mapper (e.g., LVM)

    You can see a full list in /proc/devices:
    cat /proc/devices


#

    What is a Device Type?
    =======================

    Device types tell Linux how to interact with the device:

    Type	            Description
    b	                Block device ‚Äì reads/writes data in blocks (e.g., disks, USB drives)
    c	                Character device ‚Äì reads/writes data as a stream (e.g., keyboards, serial ports)
    p	                FIFO/pipe ‚Äì for inter-process communication


    Example:

$ ls -l /dev/tty0
crw--w---- 1 root tty 4, 0 Oct 18 10:00 /dev/tty0

c ‚Üí Character device
4 ‚Üí Major (TTY driver)
0 ‚Üí Minor


#

    LSCPU
    ======
    lscpu is a Linux command-line utility that displays CPU architecture information.
    It's a quick way to inspect details about the system‚Äôs processor(s) ‚Äî such as cores, threads, sockets, CPU family, virtualization support, and more.

    It pulls information from /proc/cpuinfo and sysfs.


    What does lscpu show?
    -----------------------

    Here‚Äôs a sample output:
    Architecture:            x86_64
    CPU op-mode(s):          32-bit, 64-bit
    Byte Order:              Little Endian
    CPU(s):                  8
    On-line CPU(s) list:     0-7
    Thread(s) per core:      2
    Core(s) per socket:      4
    Socket(s):               1
    Vendor ID:               GenuineIntel
    Model name:              Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz
    Virtualization:          VT-x
    L1d cache:               32K
    L2 cache:                256K
    L3 cache:                8192K


    Key Fields Explained:

    Field	                Meaning
    Architecture	        CPU architecture (e.g., x86_64, aarch64)
    CPU(s)	                Total number of logical processors (threads)
    Thread(s) per core	    Indicates hyperthreading (2 = enabled)
    Core(s) per socket	    Physical cores per CPU
    Socket(s)	            Number of physical CPUs (usually 1 in laptops/desktops)
    Model name	            CPU branding info
    Virtualization	        Whether virtualization is supported (e.g., VT-x, AMD-V)
    Caches	                Sizes of L1, L2, L3 CPU caches


    Example Use Cases
    
    Command                 Description
    lscpu                   Show CPU layout
    lscpu -J                Display info in JSON format
    lscpu --parse=NUMA      Show NUMA info (if applicable)
    lscpu | grep '^CPU(s)'  Show only specific fields


#

    Difference vs /proc/cpuinfo
    ----------------------------

lscpu:              Structured, high-level summary (uses sysfs)

/proc/cpuinfo:      Raw per-CPU core details (e.g., flags, bugs)

Use cat /proc/cpuinfo if you need flags like sse4_2, vmx, aes, etc.


#

    LSMEM
    ======
    lsmem is a Linux command-line tool used to display information about memory (RAM) blocks in the system.

    It shows how memory is organized, online/offline, available, and reserved, especially useful on systems with hot-pluggable or NUMA memory.

    Basic Usage

lsmem

RANGE                                       SIZE         STATE       REMOVABLE       BLOCK
0x0000000000000000-0x000000007fffffff       2G           online      yes             0
0x0000000100000000-0x000000017fffffff       2G           online      yes             1

Memory block size:       2G
Total online memory:     4G
Total offline memory:    0B

    What It Shows:
    ---------------
    Field	        Meaning
    RANGE	        Physical address range of a memory block
    SIZE	        Size of each memory block
    STATE	        online (available) or offline (not available to the OS)
    REMOVABLE	    Whether the memory block can be safely removed (hot-unplug)
    BLOCK	        Logical block number assigned by the kernel

    Useful Options
    Option	                Description
    -a or --all	            Show both online and offline memory blocks
    -b	                    Display sizes in bytes
    -J	                    JSON output
    --split=STATE	        Show summary grouped by online/offline state
    --output=FIELD,...	    Show only selected fields

#

    When is lsmem Useful?
    ----------------------

    On servers with hot-pluggable memory (common in virtual machines or enterprise systems).

    To check which memory blocks are online/offline.

    When managing NUMA nodes or doing low-level system tuning.

    For debugging memory issues in advanced environments.

#

    FREE
    =====
    The **free** command displays a summary of the system‚Äôs memory usage, including:

    RAM (main memory)
    Swap space (virtual memory)
    Buffers and cache used by the kernel

    It's one of the simplest and fastest ways to check how much memory is used, free, and available.


    Basic Usage
    ------------
free

              total        used        free      shared  buff/cache   available
Mem:        16337752     2187456     9211232      321652     4949056    13509264
Swap:        2097148           0     2097148


Columns Explained

Column	            Meaning
total	            Total memory or swap installed
used	            Memory used (including buffers/cache unless using -h)
free	            Completely unused memory
shared	            Memory used by tmpfs (shared between processes)
buff/cache	        Memory used by kernel buffers and filesystem cache
available	        Estimated memory available for new apps (without swapping)


    Total RAM vs Available RAM
    ---------------------------

    If you‚Äôre confused why "used" memory looks high ‚Äî remember:

    Linux uses free RAM as disk cache to speed things up. That memory is reclaimable and not "wasted".

    "available" is a better measure of how much memory you really have free for apps.

#

    LSHW
    =====
    lshw (short for List Hardware) is a powerful command-line tool in Linux that displays detailed information about your system‚Äôs hardware ‚Äî including CPU, memory, disks, network interfaces, motherboard, and more.

    It‚Äôs like opening up your computer and reading the labels on each component ‚Äî but from the terminal.


    What Can lshw Show?

    It pulls information from /proc, /sys, and DMI/SMBIOS, giving deep, low-level details, such as:

    CPU: model, speed, capabilities
    RAM: size, configuration, slots
    Motherboard: vendor, model
    BIOS: version, date
    Storage: model, size, partitions
    Network: interfaces, speed, capabilities


    Basic Usage

sudo lshw
*-cpu
   description: CPU
   product: Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz
   vendor: Intel Corp.
   physical id: 1
   bus info: cpu@0
   size: 2112MHz
   capacity: 4200MHz
   width: 64 bits

*-memory
   description: System Memory
   physical id: 2
   size: 16GiB

*-disk
   description: ATA Disk
   product: Samsung SSD 970
   size: 512GiB


    Useful Options

    Command	                            Description
    sudo lshw	                        Full detailed output
    sudo lshw -short	                Summary table (one-liner per device)
    sudo lshw -class cpu	            Show only CPU details
    sudo lshw -class memory	            Only memory info
    sudo lshw -class disk	            Only storage info
    sudo lshw -html > system.html	    Export to HTML file
    sudo lshw -json	                    Output in JSON format


    When to Use lshw
    -----------------

    Hardware inventory collection

    Checking available RAM slots or disk models

    Verifying hardware before/after upgrades

    Troubleshooting compatibility issues

    Creating system reports (HTML/JSON)

#

    LINUX BOOT SEQUENCE
    ====================

1. BIOS / UEFI Initialization

    What happens:

    When you power on your computer, the BIOS (legacy) or UEFI (modern firmware) takes control.
    It performs a POST (Power-On Self-Test) ‚Äî checks CPU, RAM, and hardware.
    It finds a bootable device (HDD, SSD, USB) using the boot order.
    It loads the first-stage bootloader (from MBR or EFI partition) into memory and runs it.

    Key Files:

    BIOS ‚Üí Master Boot Record (MBR)
    UEFI ‚Üí EFI System Partition (ESP)

    
2. Bootloader Stage (GRUB, systemd-boot, LILO, etc.)

    What happens:
    The bootloader is responsible for loading the Linux kernel into memory.
    It can display a boot menu if you have multiple OSes or kernels.
    It also loads an initial RAM filesystem (initramfs) to help the kernel boot.

    Example (GRUB):

    GRUB loads:
    ‚Üí Kernel image: /boot/vmlinuz-6.6.87
    ‚Üí Initramfs:    /boot/initrd.img-6.6.87
    ‚Üí Passes boot parameters to kernel


3. Kernel Initialization

    What happens:
    The kernel takes over from the bootloader.
    It uncompresses itself into memory.

    Initializes:
        CPU, memory management
        Device drivers (for essential hardware)
        Mounts initramfs as temporary root filesystem

    Kernel tasks:
    Detects and configures hardware
    Mounts the real root filesystem (e.g., /dev/sda1)
    Starts the first user-space process: init (PID 1)


4. Initramfs (Initial RAM Filesystem)

    What happens:
    Temporary, small root filesystem stored in RAM.

    Contains tools and scripts to:
        Detect storage devices
        Load drivers
        Mount real root filesystem (/)

    Once the real root is ready, it‚Äôs switched, and initramfs is discarded.


5. System Initialization (init / systemd / upstart)

    What happens:
    The init system is the first process started by the kernel.
    On modern Linux, this is typically systemd (PID 1).

    It initializes:
        Target units (like runlevels)
        Services, daemons
        Network, logging, user sessions

    Older init systems:
    SysVinit (/etc/init.d/)
    Upstart (Ubuntu legacy)


6. Runlevel or Target Activation

    What happens:
    The system enters a runlevel (SysVinit) or target (systemd).

    Examples:
        Multi-user mode (no GUI)
        Graphical mode (with display manager)

    Services like sshd, nginx, cron, etc., are started.


7. User Login

    What happens:

    Once systemd reaches the target:
        The getty process starts on terminals (for text login)
        Or a display manager starts for GUI login (e.g., GDM, LightDM)

    You can now log in, and your shell (bash, zsh) starts ‚Äî in user space.

#

    LINUX BOOT SEQUENCE DIAGRAM
    =============================

    +--------------------------------------------------------------+
    |                        Power ON                              |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | BIOS / UEFI                                                  |
    |--------------------------------------------------------------|
    | - Firmware on motherboard (EEPROM chip)                      |
    | - Performs POST (Power-On Self-Test)                         |
    | - Locates boot device via Boot Order                         |
    | - Loads Bootloader from:                                     |
    |     ‚Ä¢ BIOS ‚Üí Master Boot Record (MBR) on disk (first 512 bytes)|
    |       Path:  [sector 0 of disk]                              |
    |     ‚Ä¢ UEFI ‚Üí EFI System Partition (ESP)                      |
    |       Path:  /boot/efi/EFI/<distro>/grubx64.efi              |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | Bootloader (e.g., GRUB, systemd-boot, LILO)                  |
    |--------------------------------------------------------------|
    | - Loads Kernel and Initramfs into memory                     |
    | - Provides boot menu                                         |
    | - Passes parameters to kernel                                |
    | Files typically located at:                                  |
    |   ‚Ä¢ /boot/grub/grub.cfg          ‚Üê GRUB configuration        |
    |   ‚Ä¢ /boot/vmlinuz-<version>      ‚Üê Kernel image              |
    |   ‚Ä¢ /boot/initrd.img-<version>   ‚Üê Initramfs (initrd)        |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | Linux Kernel Initialization                                  |
    |--------------------------------------------------------------|
    | - Kernel (vmlinuz) unpacks into memory                       |
    | - Initializes CPU, memory, drivers                           |
    | - Mounts temporary root (initramfs)                          |
    | - Starts first user-space process: /sbin/init (PID 1)        |
    | Files/paths:                                                 |
    |   ‚Ä¢ /boot/vmlinuz-<version>     ‚Üê kernel binary              |
    |   ‚Ä¢ /proc, /sys, /dev           ‚Üê virtual kernel filesystems |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | Initramfs (Initial RAM Filesystem)                           |
    |--------------------------------------------------------------|
    | - Temporary root filesystem (in RAM)                         |
    | - Contains tools & scripts for early boot                    |
    | - Mounts real root (e.g. /dev/sda1)                          |
    | - Switches root to the real filesystem                       |
    | Files/paths:                                                 |
    |   ‚Ä¢ /boot/initrd.img-<version>  ‚Üê compressed cpio archive    |
    |   ‚Ä¢ /init (inside initramfs)    ‚Üê script that mounts rootfs  |
    |   ‚Ä¢ /etc/fstab                  ‚Üê mount instructions         |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | Init System (systemd / SysVinit / Upstart)                   |
    |--------------------------------------------------------------|
    | - First process started by kernel (PID 1)                    |
    | - Initializes services and targets                           |
    | - Prepares user environment                                  |
    | Common file locations:                                       |
    |   ‚Ä¢ /sbin/init ‚Üí usually a symlink to /lib/systemd/systemd   |
    |   ‚Ä¢ /etc/systemd/system/       ‚Üê custom unit files           |
    |   ‚Ä¢ /lib/systemd/system/       ‚Üê default unit files          |
    |   ‚Ä¢ /etc/inittab (for SysVinit)                              |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | Runlevel / Target Activation                                 |
    |--------------------------------------------------------------|
    | - Brings up all configured services and daemons              |
    | - Mounts local & network filesystems                         |
    | - Enables networking, logging, cron, etc.                    |
    | Files/paths:                                                 |
    |   ‚Ä¢ /etc/systemd/system/multi-user.target.wants/             |
    |   ‚Ä¢ /etc/rc*.d/ (for SysVinit scripts)                       |
    |   ‚Ä¢ /etc/fstab (for mounting drives)                         |
    +--------------------------------------------------------------+
                    ‚îÇ
                    ‚ñº
    +--------------------------------------------------------------+
    | User Space (Login / Shell / GUI)                             |
    |--------------------------------------------------------------|
    | - getty ‚Üí login prompt on terminal                           |
    | - GUI ‚Üí Display Manager (GDM, LightDM)                       |
    | - User logs in ‚Üí shell (bash, zsh) starts                    |
    | - Desktop environment starts (if GUI)                        |
    | User-space binaries and configs:                             |
    |   ‚Ä¢ /bin/, /usr/bin/        ‚Üê user commands (ls, cat, bash)  |
    |   ‚Ä¢ /etc/passwd, /etc/shadow ‚Üê user info                     |
    |   ‚Ä¢ /home/<user>/           ‚Üê user data                      |
    +--------------------------------------------------------------+


#

ls -l /sbin/init                        // To check the init system used

lrwxrwxrwx 1 root root 22 Jul 11 20:52 /sbin/init -> ../lib/systemd/systemd

#

    RUNLEVEL
    =========
    A runlevel is a mode of operation in traditional Linux systems (especially those using SysVinit) that defines what services and processes should be running.

    Think of it as the system‚Äôs operational state ‚Äî
    for example, ‚Äúsingle-user mode,‚Äù ‚Äúmulti-user mode,‚Äù or ‚Äúgraphical mode.‚Äù


    How Runlevels Work (SysVinit System)
    -------------------------------------

    When the system boots:
    The kernel starts the init process (PID 1).
    The init program reads /etc/inittab to determine which runlevel to start in.
    Based on the runlevel, init runs scripts from directories like /etc/rcX.d/
    (where X = runlevel number).

    Each runlevel defines what services should start or stop.


    Standard Linux Runlevels
    -------------------------
    Runlevel	        Name / Mode	                        Description
    0	                Halt	                            Shuts down the system
    1	                Single-user mode	                Maintenance mode ‚Äî only root user, no networking
    2	                Multi-user (no network)	            Multiple users, no network services (rarely used)
    3	                Multi-user (text mode)	            Normal multi-user mode with networking (no GUI)
    4	                Undefined / Custom	                Not used by default ‚Äî available for custom configs
    5	                Graphical mode	                    Multi-user with networking and GUI (X11 or Wayland)
    6	                Reboot	                            Reboots the system


    Runlevel Directory Structure

    Each runlevel has its own folder in /etc/:

    /etc/rc0.d/    ‚Üí scripts to run when entering runlevel 0
    /etc/rc1.d/    ‚Üí scripts for single-user mode
    /etc/rc2.d/    ‚Üí scripts for multi-user mode
    /etc/rc3.d/    ‚Üí scripts for full multi-user mode
    /etc/rc5.d/    ‚Üí scripts for GUI mode
    /etc/rc6.d/    ‚Üí scripts for reboot

    Inside each directory:

    Files starting with S ‚Üí services to Start
    Files starting with K ‚Üí services to Kill (stop)

    Example:
    /etc/rc3.d/
        ‚îú‚îÄ‚îÄ S01rsyslog
        ‚îú‚îÄ‚îÄ S02network
        ‚îú‚îÄ‚îÄ S20sshd
        ‚îú‚îÄ‚îÄ K01gdm


    SYSTEMD AND RUNLEVEL
    ----------------------

    Modern Linux distributions (Ubuntu 16+, RHEL 7+, Debian 8+, etc.) use systemd, which replaces SysVinit and runlevels with targets.

    Runlevel	    Equivalent systemd Target	            Command to Use
    0	            poweroff.target	                        systemctl isolate poweroff.target
    1	            rescue.target	                        systemctl isolate rescue.target
    3	            multi-user.target	                    systemctl isolate multi-user.target
    5	            graphical.target	                    systemctl isolate graphical.target
    6	            reboot.target	                        systemctl isolate reboot.target

    +---------------------------------------------------------------+
    |                   Linux Runlevels and systemd Targets         |
    +---------------------------------------------------------------+
    |                                                               |
    |  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê|
    |  ‚îÇ Runlevel   ‚îÇ SysV Description         ‚îÇ systemd Target    ‚îÇ|
    |  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§|
    |  ‚îÇ 0          ‚îÇ Halt / Poweroff          ‚îÇ poweroff.target   ‚îÇ|
    |  ‚îÇ 1          ‚îÇ Single-user / Rescue     ‚îÇ rescue.target     ‚îÇ|
    |  ‚îÇ 2          ‚îÇ Multi-user (no network)  ‚îÇ multi-user.target*‚îÇ|
    |  ‚îÇ 3          ‚îÇ Full multi-user (text)   ‚îÇ multi-user.target ‚îÇ|
    |  ‚îÇ 4          ‚îÇ Undefined / Custom use   ‚îÇ (custom target)   ‚îÇ|
    |  ‚îÇ 5          ‚îÇ Graphical mode (GUI)     ‚îÇ graphical.target  ‚îÇ|
    |  ‚îÇ 6          ‚îÇ Reboot                   ‚îÇ reboot.target     ‚îÇ|
    |  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò|
    |                                                               |
    |  * Some distros (e.g., Debian) use runlevel 2 for normal mode |
    |    with networking.                                           |
    +---------------------------------------------------------------+


#

ls -l /sbin/init                    // To find whether system uses systemd or not
lrwxrwxrwx 1 root root 20 Feb  6  2020 /sbin/init -> /lib/systemd/systemd


systemctl get-default               // To check the current target
graphical.target


ls -ltr /etc/systemd/system/default.target      // it shows the target file content
/etc/systemd/system/default.target -> /lib/systemd/system/graphical.target


systemctl set-default multi-user.target         // Change the target
Created symlink /etc/systemd/system/default.target -> lib/systemd/system/multi-user.target


#
    Note : Runlevels define what services the system runs at boot, systemd replaced them with targets, but the concept is still the same.

#

    FILE TYPES IN LINUX
    --------------------
    In Linux, everything is treated as a file, whether it‚Äôs a text document, a device, or even a directory.
    Each file has a type, which tells the system how to handle it.


#

    Main File Types
    Symbol	            Type	            Description
    -	                Regular file	    Normal files ‚Äî text, binary, executables, etc.
    d	                Directory	        A folder containing files or subdirectories.
    l	                Symbolic link	    A shortcut or reference to another file. (hardlink and softlink)
    c	                Character device	For devices that handle data character by character (e.g., keyboard, serial port).
    b	                Block device	    For devices that handle data in blocks (e.g., hard drives, RAM).
    s	                Socket	            Used for inter-process communication (e.g., networking).
    p	                Named pipe (FIFO)	Enables communication between processes. Allows connecting one process as an input to another, unidirectional.

#

    How to Identify File Types
    ---------------------------

1. Using ls -l

    The first character in the output indicates the file type:

ls -l


    Example output:

    -rw-r--r--  1 user user  1200 Oct 18  report.txt            ‚Üí regular file
    drwxr-xr-x  2 user user  4096 Oct 18  docs/                 ‚Üí directory
    lrwxrwxrwx  1 user user    11 Oct 18  link -> report.txt    ‚Üí symlink
    crw-rw----  1 root tty  4, 1 Oct 18  /dev/tty1              ‚Üí character device
    brw-rw----  1 root disk 8, 0 Oct 18  /dev/sda               ‚Üí block device
    srw-rw-rw-  1 root root    0 Oct 18  /run/docker.sock       ‚Üí socket
    prw-r--r--  1 user user    0 Oct 18  /tmp/testpipe          ‚Üí named pipe

2. Using file command

    The file command inspects the content and tells what kind of data a file holds:

file report.txt
    Output:
    report.txt: ASCII text


file /bin/ls
    Output:
    /bin/ls: ELF 64-bit LSB executable


#

    FILESYSTEM HIERARCHY
    =====================
    The Filesystem Hierarchy in Linux defines how files and directories are organized in the system.Everything starts from the root directory (/), and all other files and 
    folders branch out from it ‚Äî like a tree.

#


    Directory	    Detailed Description	                                                                                                    Example Commands
    /	            The root directory is the topmost level of the Linux filesystem. Every single file and directory originates from here.      ls /, df -h /, sudo du -sh /*
                    It acts as the parent for all other paths.

    /boot	        Holds boot-related files required to start the system, including the Linux kernel (vmlinuz), initramfs, and bootloader      ls /boot, cat /boot/grub/grub.cfg, uname -r
                    configuration files like GRUB. Without this directory, the OS cannot boot.

    /root	        The home directory for the root (superuser) account. It‚Äôs separate from /home for security and recovery reasons. Only       sudo -i, cd /root, ls -la /root
                    accessible by the root user.

    /home	        Contains personal directories for regular users. Each user gets a subdirectory (e.g., /home/alex) that holds personal       ls /home, cd ~, du -sh /home/*
                    files, settings, and documents.	

    /bin	        Contains essential user command binaries needed for basic system operation and maintenance (used by all users). These       ls /bin, /bin/ls, which cp
                    include commands like ls, cp, mv, and cat that are available even in single-user mode.

    /sbin	        Contains system administration binaries used by the root user for managing the system (e.g., fsck, ifconfig, reboot).       ls /sbin, which fsck, /sbin/reboot
                    These are not usually in a regular user‚Äôs PATH.	

    /lib, /lib64	Houses shared libraries (similar to Windows DLLs) and kernel modules needed by essential binaries in /bin and /sbin.        ls /lib, ldd /bin/ls
                    These libraries are critical for system startup and basic functionality.

    /proc	        A virtual filesystem dynamically generated by the kernel. It provides information about running processes, system           ls /proc, cat /proc/cpuinfo, cat /proc/meminfo, ps -ef
                    memory, CPU, and kernel parameters. Files like /proc/cpuinfo and /proc/meminfo expose real-time data.

    /sys	        A virtual filesystem that provides detailed information and configuration interfaces for kernel objects and devices         ls /sys, cat /sys/class/net/eth0/operstate
                    (via sysfs). Used to tune kernel parameters and view device states.	

    /dev	        Contains device files that represent physical or virtual hardware components like disks (/dev/sda), terminals (/dev/tty),   ls /dev, lsblk, `dmesg
                    and USB drives. Linux treats devices as files, allowing input/output through the filesystem.

    /media	        Used as a mount point for removable media like USB drives, CDs, and DVDs. When you insert removable media, the system       ls /media, mount, umount /media/usb
                    usually mounts it here automatically.

    /opt	        Contains optional or third-party application software packages. Vendors often install their products here to avoid          ls /opt, du -sh /opt/*
                    cluttering system directories (e.g., /opt/google/chrome).

    /mnt	        A temporary mount point for mounting external filesystems or storage devices manually by administrators. Commonly used      sudo mount /dev/sdb1 /mnt, ls /mnt, sudo umount /mnt
                    during maintenance or troubleshooting.	

    /etc	        Stores system-wide configuration files for the operating system and installed services. This includes network settings,     ls /etc, cat /etc/passwd, grep root /etc/group
                    user accounts, and daemon configurations (e.g., /etc/ssh/sshd_config, /etc/fstab).

    /run	        Stores runtime data like process IDs (PIDs), sockets, and temporary files used by system services after boot. The data in   ls /run, cat /run/utmp, systemctl status
                    /run is cleared at every reboot.

    /srv	        Holds service data directories for system services such as web servers (/srv/www) or FTP servers (/srv/ftp). Used for       ls /srv, du -sh /srv/*
                    storing data served by network services.

    /tmp	        Used to store temporary files created by users or applications. Data here is typically cleared at reboot. Accessible by     ls /tmp, touch /tmp/test.txt, rm /tmp/test.txt
                    all users but with restricted permissions.

    /usr	        Contains secondary user programs, libraries, documentation, and utilities not needed for system boot. Subdirectories        ls /usr, `ls /usr/bin
                    include /usr/bin, /usr/lib, and /usr/share.

    /var	        Contains variable data that changes frequently during system operation, such as logs, mail, print spools, and caches.       ls /var, ls /var/log, tail -f /var/log/syslog
                    Logs in /var/log are crucial for troubleshooting.


#

    Concept Diagram (Text Format)
    ------------------------------
        /
        ‚îú‚îÄ‚îÄ bin      ‚Üí essential user commands
        ‚îú‚îÄ‚îÄ sbin     ‚Üí essential system admin commands
        ‚îú‚îÄ‚îÄ etc      ‚Üí configuration files
        ‚îú‚îÄ‚îÄ lib      ‚Üí shared libraries
        ‚îú‚îÄ‚îÄ var      ‚Üí logs, mail, spool, temp data
        ‚îú‚îÄ‚îÄ usr      ‚Üí user programs, documentation
        ‚îú‚îÄ‚îÄ home     ‚Üí user home directories
        ‚îú‚îÄ‚îÄ boot     ‚Üí kernel, bootloader files
        ‚îú‚îÄ‚îÄ dev      ‚Üí device files
        ‚îú‚îÄ‚îÄ tmp      ‚Üí temporary files
        ‚îú‚îÄ‚îÄ proc     ‚Üí process and kernel info (virtual)
        ‚îî‚îÄ‚îÄ root     ‚Üí root user's home

#

    Quick Commands to Explore
    --------------------------
ls /
ls /bin
ls /etc
ls /usr/bin | head


#

    LINUX PACKAGE MANAGEMENT
    =========================

    A package manager is a tool that automates the process of installing, upgrading, configuring, and removing software packages in Linux.

    It handles:

    Dependency resolution (installing required libraries automatically)
    Version management
    Repository access (downloading from verified sources)

#

    PACKAGE
    ========
    A package in Linux is a bundle of files that contains everything needed to install and run a piece of software.

    It usually includes:

    The program‚Äôs executable files
    Configuration files
    Dependency information (what other software it needs)
    Metadata (version, description, maintainer info)

    Packages are typically stored in specific file formats depending on the Linux distribution, such as:

    .deb ‚Üí for Debian-based systems (Ubuntu, Debian)
    .rpm ‚Üí for Red Hat-based systems (RHEL, CentOS, Fedora)

#

    Types of Package Managers (by Linux Distribution)
    ==================================================

    Linux Family	    Common Distros	                        Package Format	    Package Manager	                    Example Commands
    -------------       ---------------                         ---------------     ----------------                    ------------------
    Debian-based	    Ubuntu, Debian, Kali	                .deb	            APT (Advanced Package Tool)	        sudo apt update, sudo apt install nginx
    Red Hat-based	    RHEL, CentOS, Fedora, Rocky, AlmaLinux	.rpm	            YUM / DNF	                        sudo dnf install httpd, sudo yum update
    SUSE-based	        openSUSE, SLES	                        .rpm	            Zypper	                            sudo zypper install vim
    Arch-based	        Arch, Manjaro	                        .pkg.tar.zst	    Pacman	                            sudo pacman -S firefox
    Alpine-based	    Alpine Linux	                        .apk	            APK	                                sudo apk add curl
    Gentoo-based	    Gentoo	                                Source (compiled)	Portage (emerge)	                sudo emerge --ask vim
    Slackware-based	    Slackware	                            .tgz	            pkgtool / slackpkg	                sudo slackpkg install package


#

    rpm - RedHat Package Manager
    YUM - Yellowdog Update modified

#

    Functions of a Package Manager
    ===============================
    Function	                Description	                                                Example Commands
    Install	                    Add new software packages to your system.	                sudo apt install nginx / sudo dnf install nginx / sudo pacman -S nginx
    Update	                    Update the package index (list of available packages).	    sudo apt update / sudo dnf check-update / sudo pacman -Sy
    Upgrade	                    Upgrade all installed packages to newer versions.	        sudo apt upgrade / sudo dnf upgrade / sudo pacman -Su
    Remove / Uninstall	        Remove an installed package cleanly.	                    sudo apt remove nginx / sudo dnf remove nginx / sudo pacman -R nginx
    Remove (with config)	    Completely remove package + config files.	                sudo apt purge nginx / sudo dnf erase nginx
    Dependency Handling	        Installs or removes required dependencies automatically.	(Implicit when using apt, dnf, or pacman)
    List Installed Packages	    Show all installed packages.	                            dpkg -l / rpm -qa / pacman -Q
    Search for a Package	    Search repositories for software.	                        apt search nginx / dnf search nginx / pacman -Ss nginx
    Show Package Info	        Display details about a package.	                        apt show nginx / dnf info nginx / pacman -Qi nginx
    Manage Repositories	        Add or remove software sources.	                            sudo add-apt-repository ppa:deadsnakes/ppa / edit /etc/yum.repos.d/*.repo
    Verify Package Integrity	Check authenticity and signature of a package.	            dpkg --verify / rpm --checksig package.rpm
    Clean Cache	                Clear or manage locally stored package files.	            sudo apt clean / sudo dnf clean all / sudo pacman -Sc
    Rollback / Undo	            Revert to an earlier package state (if supported).	        sudo dnf history undo last / manually reinstall an older .deb / .rpm
    Security Enforcement	    Ensure packages come from trusted, signed sources.	        apt-key list / rpm -qi gpg-pubkey*


#

    Linux Package Manager Families ‚Äî Organized Summary
    ===================================================
    Linux Family	                                Package Format	    High-Level Tool	    Low-Level Tool	    How It Works	                                                                                                Summary
    Debian / Ubuntu / Kali / Mint	                .deb	            apt	                dpkg	            apt fetches packages from repositories, resolves dependencies, and calls dpkg to install and configure files.	apt is the user-friendly front-end; dpkg performs the actual unpacking and installation.
    Red Hat / Fedora / CentOS / Rocky / AlmaLinux	.rpm	            dnf / yum	        rpm	                dnf or yum manages repositories, handles dependencies, and uses rpm underneath to install and verify packages.	dnf is the modern replacement for yum; both use rpm for actual installation.
    openSUSE / SLES	                                .rpm	            zypper	            rpm	                zypper provides repo and dependency management while rpm performs low-level installation.	                    zypper simplifies dependency handling; rpm does the backend work.
    Arch / Manjaro	                                .pkg.tar.zst	    pacman	            (Single-level)	    pacman directly handles repositories, downloads, dependency resolution, and installs packages.	                pacman is both front-end and back-end ‚Äî simple and fast.
    Alpine Linux	                                .apk	            apk	                (Single-level)	    apk manages repositories and installs lightweight .apk packages directly, designed for minimal systems.	        apk is optimized for container use and small footprint systems.
    Gentoo Linux	                                Source	            emerge (Portage)	(Build-based)	    emerge downloads source code, compiles it locally, and installs the resulting binaries.	                        Gentoo‚Äôs Portage offers maximum customization ‚Äî everything built from source.


#

    Universal Package Managers
    ===========================
    Tool	        Works On	            Purpose	                                        Example Command
    Snap	        Most Linux distros	    Containerized universal apps	                sudo snap install code --classic
    Flatpak	        Most Linux distros	    Sandboxed desktop apps	                        flatpak install flathub org.mozilla.firefox
    AppImage	    Any Linux distro	    Portable standalone apps (no install needed)	./AppName-x86_64.AppImage


#

    Linux Package Managers ‚Äî Full Form & Repository Locations
    Package Manager / Tool	            Full Form	                    Linux Family / Distro	            Package Format	            Repository Location(s)
    APT	                                Advanced Package Tool	        Debian, Ubuntu, Kali, Mint	        .deb	                    Remote: /etc/apt/sources.list, /etc/apt/sources.list.d/
                                                                                                                                        Local cache: /var/cache/apt/archives/

    DPKG	                            Debian Package	                Debian-based	                    .deb	                    Installs from local files (no repos): manually downloaded .deb packages.
    

    YUM	                                Yellowdog Updater, Modified	    CentOS, RHEL (older)	            .rpm	                    Remote: /etc/yum.repos.d/*.repo
                                                                                                                                        Local cache: /var/cache/yum/

    DNF	                                Dandified YUM	                Fedora, RHEL 8+, Rocky, AlmaLinux	.rpm	                    Remote: /etc/yum.repos.d/*.repo
                                                                                                                                        Metadata cache: /var/cache/dnf/

    RPM	                                Red Hat Package Manager	        RHEL, Fedora, SUSE	                .rpm	                    Local installation only (no repo management): /var/lib/rpm/ holds installed package database.
    

    Zypper	                            (No expansion; SUSE tool)	    openSUSE, SLES	                    .rpm	                    Repo configs: /etc/zypp/repos.d/
                                                                                                                                        Cache: /var/cache/zypp/

    Pacman	                            Package Manager	                Arch Linux, Manjaro	                .pkg.tar.zst	            Remote: /etc/pacman.conf, /etc/pacman.d/mirrorlist
                                                                                                                                        Local cache: /var/cache/pacman/pkg/

    APK	                                Alpine Package Keeper	        Alpine Linux	                    .apk	                    Repos: /etc/apk/repositories
                                                                                                                                        Cache: /var/cache/apk/

    Emerge	                            (Part of Portage system)	    Gentoo Linux	                    Source	                    Repos (Portage tree): /var/db/repos/gentoo/ or /usr/portage/


    Portage	                            (Name only)	                    Gentoo Linux	                    Source	                    Configuration: /etc/portage/
                                                                                                                                        Builds source packages in /var/tmp/portage/
                                                                                                                            
    Snap	                            (Canonical tool; no expansion)	Most Linux distros	                .snap	                    Remote (store): https://api.snapcraft.io/
                                                                                                                                        Local: /var/lib/snapd/snaps/

    Flatpak	                            (No expansion; from Red Hat)	Most Linux distros	                .flatpakref, .flatpakrepo	Repos: /var/lib/flatpak/repo/, 
                                                                                                                                        user: ~/.local/share/flatpak/
    
    AppImage	                        (Self-contained term)	        Any Linux distro	                .AppImage	                No repository ‚Äî portable executables stored anywhere (e.g., ~/Applications/).


#

    Note : The repo links can be updated, pointing to a repository containing newer or unique packages.


#

    LINUX SHELL 
    ============
    A shell is a program that acts as an interface between you (the user) and the Linux operating system (kernel).
    You type commands ‚Üí the shell interprets them ‚Üí the system executes them ‚Üí results are shown back to you.

    Think of it as your command interpreter or command-line environment.

    User types a command (e.g., ls)
    Shell interprets it and passes it to the Kernel
    Kernel performs the requested task (list files)
    Shell displays the output back to the user

#

    Common Types of Linux Shells
    Shell	                            Path	                Description
    Bourne Shell (sh)	                /bin/sh	                Original Unix shell by Stephen Bourne
    Bash (Bourne Again Shell)	        /bin/bash	            Most common; improved version of sh
    C Shell (csh / tcsh)	            /bin/csh	            Syntax similar to C language
    Korn Shell (ksh)	                /bin/ksh	            Adds scripting and performance improvements
    Z Shell (zsh)	                    /bin/zsh	            Modern shell with better completion and plugins
    Fish (Friendly Interactive Shell)	/usr/bin/fish	            User-friendly, colorful, auto-suggestions


#

echo $SHELL                             // Check Which Shell You‚Äôre Using
    Example output:
    /bin/bash

chsh -s /bin/zsh                        // Switching Shells (Change default shell to zsh)

#

    Linux Commands to Check File Size
    ----------------------------------

    Command	            Purpose / Description	                                                    Key Options Explained	                                    Example	Sample      Output / Notes
    ls -lh	            Lists files in a directory with human-readable sizes (e.g., KB, MB, GB).	-l: Long listing format (permissions, owner, size, date)    ls -lh file.txt	    -rw-r--r-- 1 user user 2.3M Oct 18 10:15 file.txt
                                                                                                -h: Human-readable (adds K/M/G suffixes)	

    du -h file.txt	    Shows the disk space usage of a single file.	                            -h: Human-readable sizes	                                du -h file.txt	    2.4M file.txt
                                                                                                                                                                                    üîπ Shows actual space used on disk (can differ from ls due to block allocation).

    du -sh /path/to/dir	Displays the total size of a directory (without listing subfiles).	        -s: Summary only (don‚Äôt list each file)                     du -sh /var/log	    450M /var/log
                                                                                                    -h: Human-readable	                                    
    
    du -ah	            Lists the size of all files and subdirectories under a path.	            -a: Include all files (not just directories)                du -ah /home/user	Shows every file‚Äôs size recursively.
                                                                                                    -h: Human-readable
                                                                                                    	        
    `du -ah	sort -h`	Lists all files with sizes, sorted from smallest to largest.	            sort -h: Sorts human-readable sizes (e.g., 2K < 1M < 1G)	`du -ah
    
    stat file.txt	    Displays detailed metadata of a file including its size in bytes.	        (no specific flags needed)	                                stat file.txt	    Size: 2432000 Blocks: 4768
                                                                                                                                                                                    üîπ Exact size (in bytes), not rounded.
    
    find . -type f -size +100M	Finds files larger than 100 MB within the current directory.	    -type f: File only
                                                                                                    -size +100M: Larger than 100 MB	find .                      -type f -size +100M	Lists paths of all files >100 MB.

    `find . -type f -size +100M -exec du -h {} +	sort -h`	Combines find and du to list large files with sizes, sorted ascending.	-exec ... +: Runs a command (here du -h) on each found file	`find . -type f -size +100M -exec du -h {} +
    
    ls -lhS	            Lists files sorted by size (largest first).	                                -S: Sort by file size (descending by default)	            ls -lhS	            Shows largest files at the top of the list.
    
    `du -ch *	        grep total`	                                                                Shows total size of all files in the current directory.	    -c: Adds a grand total              `du -ch *
                                                                                                                                                                grep total: Filters the total line	

#

    Tips
    =====

    ls shows file sizes as stored in the filesystem‚Äôs metadata.
    du shows disk space used, which can differ (e.g., due to sparse files or block size).
    Always use the -h flag to make outputs easier to read (KB/MB/GB).
    Combine du, sort, and find for quick analysis of space usage.


#           [Day-10]


    Linux Compression & Decompression Commands Reference
    =====================================================

    Tool	        Compression Command	    Decompression Command	        Key Options / Switches	    Description / Use-case	            Approx. Speed	    Compression Ratio	            Example
    -----           --------------------    ----------------------          -----------------------     -----------------------             --------------      -------------------             ---------

    gzip	        gzip file	            gunzip file.gz or 	            -9 (max compression), 	    Classic, fast single-threaded 	    üîπ Very fast	    üî∏ Medium (2.5:1 ‚Äì 3.5:1)	   gzip -9 report.txt ‚Üí report.txt.gz
                                            gzip -d file.gz                 -1 (fastest),               compressor, common for .gz 
                                                                            -r (recursive),             and tar archives
                                                                            -c (stdout)


    bzip2	        bzip2 file	            bunzip2 file.bz2 or 	        -9 (max compression), 	    Slower than gzip but smaller 	    ‚ö™ Medium	        üîπ Better (3:1 ‚Äì 5:1)	      bzip2 -9 data.log
                                            bzip2 -d file.bz2               -1 (fastest),               files, often used for source 
                                                                            -k (keep original),         code archives
                                                                            -v (verbose)
    
    
    xz	            xz file	                unxz file.xz or 	            -0 to -9 (levels), 	        Excellent ratio using LZMA2; 	    üî∏ Slow	            üîπ High (4:1 ‚Äì 8:1)	           xz -9 -T0 backup.img
                                            xz -d file.xz                   -k, -T0 (multi-thread),     replaces bzip2 in many distros
                                                                            -v

    zip	            zip archive.zip file	unzip archive.zip	            -r (recursive), -9 (max), 	Cross-platform, supports multiple 	üîπ Fast	            üî∏ Medium (2:1 ‚Äì 3:1)	       zip -r logs.zip /var/log
                                                                            -e (encrypt), -x (exclude)  files; Windows compatible


    tar + gzip	    tar -czf archive.tar.gz tar -xzf archive.tar.gz	        -c (create), -x (extract), 	Combines multiple files into one 	üîπ Fast	            üî∏ Medium	                   tar -czf project.tar.gz project/
                    dir                                                     -z (gzip), -f (file)        .tar and compresses
    
    
    tar + bzip2	    tar -cjf archive.tar.bz2 tar -xjf archive.tar.bz2	    -j (bzip2)	                Better compression than gzip, 	    ‚ö™ Medium	       üîπ Higher	                  tar -cjf src.tar.bz2 src/
                    dir                                                                                 slower
    
    tar + xz	    tar -cJf archive.tar.xz tar -xJf archive.tar.xz	        -J (xz)	                    Very efficient compression for 	    üî∏ Slow	            üîπ Highest	                   tar -cJf backup.tar.xz /home/user
                    dir                                                                                 large archives
    
    7z (p7zip)	    7z a archive.7z file	7z x archive.7z	                -mx=9 (max), 	            Advanced multi-format tool  	    ‚ö™ Medium	       üîπ Very high (5:1 ‚Äì 10:1)	  7z a -mx=9 logs.7z /var/log
                                                                            -mmt=on (multi-thread),     (7z, zip, tar, etc.)
                                                                            -p (password), -t7z (type)


    rar (nonfree)	rar a archive.rar file	unrar x archive.rar	            -m5 (max), -p (password), 	Proprietary format, good ratio, 	‚ö™ Medium	       üîπ High	                      rar a -m5 data.rar data/
                                                                            -r (recursive)              multi-volume support
    
    
    zstd (Zstandard)    zstd file	        unzstd file.zst or 	            -1 (fastest) to -19 (max), 	Facebook-developed, extremely 	    üîπ Very fast	    üîπ High (2.5:1 ‚Äì 5:1)	       zstd -19 large.log
                                            zstd -d file.zst                -T0 (multi-thread),         fast with good ratio; modern 
                                                                            --rm (remove input)         replacement for gzip
    

    lz4	                lz4 file	        lz4 -d 	                        -1 (fastest), -9 (max), 	Lightning-fast compression, 	    üü¢ Extremely fast	üî∏ Low (1.5:1 ‚Äì 2.5:1)	       lz4 -9 database.dump
                                            file.lz4                        -v                          lower ratio; used in kernels/logs

    
    lzop	            lzop file	        lzop -d file.lzo	            -1 (fastest) to -9, 	    Based on LZO algorithm; very fast, 	üü¢ Extremely fast	üî∏ Low‚Äìmedium	                lzop -9 image.iso
                                                                            -v, -k                      moderate ratio
    

    compress / 	        compress file	    uncompress file.Z	            -v (verbose), -f (force)	Legacy UNIX tool (.Z extension), 	‚ö™ Medium	       üî∏ Low‚Äìmedium	               compress notes.txt
    uncompress                                                                                          rarely used now
    

    pigz 	            pigz file	        unpigz file.gz	                -p <n> (threads), -9, 	    Multi-core parallel version of      üîπ Very fast 	    üî∏ Medium (same as gzip)	    pigz -p 8 -9 backup.tar
    (Parallel gzip)                                                         -k, -v                      gzip; same format (.gz)             (multi-thread)
    

    pbzip2 	            pbzip2 file	        pbunzip2 file.bz2	            -p<N> (threads), -v, -k	    Multi-threaded version of bzip2	    ‚ö™ Medium‚Äìfast	   üîπ High	                       pbzip2 -p4 logs.txt
    (Parallel bzip2)
    

    plzip / lzip	    lzip file	        lzip -d file.lz	                -9, -k, -v, -t (test)	    LZMA-based, high ratio,     	    üî∏ Slow	            üîπ Very high	                lzip -9 image.iso
                                                                                                        good integrity checking
    

    archiver 	        tar --zstd -cf 	    tar --zstd -xf 	                --zstd	                    Best combo: fast + good compression	üîπ Very fast	    üîπ High	tar                     --zstd -cf site.tar.zst /var/www
    (tar+zstd)          archive.tar.zst     archive.tar.zst
                        dir



    Performance Summary (Typical Compression vs Speed Trade-offs)
    ==============================================================

    Category	                    Tools	                            Relative Speed	        Typical Ratio	        Best Use
    --------                        ------                              ---------------         --------------          ---------

    üü¢ Very Fast	                lz4, lzop, pigz, zstd -1..3	        ‚ö°‚ö°‚ö°	                ~2:1	                Logs, backups where speed > ratio
    ‚ö™ Balanced	                   gzip, pbzip2, zstd -10, 7z -mx=5	   ‚ö°‚ö°	                ~3‚Äì5:1	                General use, packaging
    üî∏ High Compression (Slower)	xz, 7z -mx=9, zstd -19	            ‚ö°	                  ~5‚Äì10:1	               Archival storage, containers
    üî¥ Legacy / Rare	            compress, rar, lzip	                ‚ö°	                   varies	               Compatibility or niche cases



    Common ‚ÄúAll-in-One‚Äù Examples
    ==============================

    Task	                                    Command	                                                Notes
    -----                                       ---------                                               -------

    Create a .tar.gz archive	                tar -czf archive.tar.gz /dir	                        Combines tar + gzip
    Extract a .tar.xz archive	                tar -xJf archive.tar.xz	                                tar auto-detects compression
    Compress with multi-thread gzip	            pigz -p 8 myfile	                                    Same .gz output but much faster
    Compress with best modern trade-off	        zstd -19 bigfile	                                    High ratio, faster than xz
    Archive directory with zstd	                tar --zstd -cf backup.tar.zst /home/user	            Modern, fast, and efficient
    Benchmark compression	                    time gzip -9 bigfile	                                Measure speed vs. ratio
    Test compressed file integrity	            gzip -t file.gz, xz -t file.xz, zstd -t file.zst	    All support test modes



    Practical Tips
    ===============

    Always test after decompression:
    gzip -t, xz -t, zstd -t, tar -tvf

    To stream compression over network:
    tar -cf - dir | zstd -19 -T0 | ssh user@host "cat > backup.tar.zst"

    To view contents without extracting:
    tar -tf archive.tar.gz

    To combine decompression and extraction:
    tar -xvf archive.tar.*

    To compare ratios quickly:
    ls -lh file* (compare original and compressed sizes)



    Quick Recommendation by Scenario
    =================================

    Scenario	                                Recommended Tool
    ---------                                   -----------------

    General-purpose archival	                tar + zstd
    Cross-platform zip sharing	                zip/unzip
    Highest compression (archival)	            xz -9 or 7z -mx=9
    Fastest compression (logs, temp backups)	lz4 or zstd -1
    Multi-core compression	                    pigz, pbzip2, zstd -T0
    Legacy UNIX support	                        gzip
    Minimal CPU (low power systems)	            lzop


#           [Day-11]


 1. Searching for Files by Name or Type
 ========================================

    Command	                                Description	                                                Example
    --------                                ------------                                                --------
    find /path -name "*.log"	            Find all .log files under a directory	                    find /var/log -name "*.log"
    find . -type f -name "config*.json"	    Find files starting with ‚Äúconfig‚Äù and ending in .json	    find . -type f -name "config*.json"
    find /var/log -type f -mtime -1	        Files modified in the last 1 day	                        find /var/log -type f -mtime -1
    find /etc -type f -size +10M	        Files larger than 10 MB	                                    find /etc -type f -size +10M
    find . -perm 644	                    Files with permission 644	                                find . -perm 644
    find / -user ubuntu	                    Files owned by the ubuntu user	                            find / -user ubuntu
    find . -iname "*.txt"	                Case-insensitive search for .txt files	                    find . -iname "*.txt"
    find . -maxdepth 2 -name "*.py"	        Limit recursion depth to 2 directories	                    find . -maxdepth 2 -name "*.py"
    find /var -type f -exec ls -lh {} \;	Run a command (ls -lh) on each found file	                find /var -type f -exec ls -lh {} \;
    find . -empty -type f	                Find empty files	                                        find . -empty -type f
    find /tmp -atime -1	                    Files accessed within the last 24 hours	                    find /tmp -atime -1
    find /home -mtime +30	                Files modified more than 30 days ago	                    find /home -mtime +30
    find /var -size +1G	                    Files larger than 1 GB	                                    find /var -size +1G
    find . -type d -name "backup"	        Find directories named ‚Äúbackup‚Äù	                            find . -type d -name "backup"
    find /etc -type f ! -perm 644	        Files that don‚Äôt have 644 permission	                    find /etc -type f ! -perm 644


    üëâ Tip: Use -maxdepth to limit recursion depth.
    Example: find . -maxdepth 2 -name "*.py"


 2. Searching for Text Patterns Inside Files
 ============================================

    Command	                                Description	                                                Example
    grep "ERROR" app.log	                Search for lines containing ‚ÄúERROR‚Äù	                        grep "ERROR" /var/log/syslog
    grep -i "error" app.log	                Case-insensitive match	                                    grep -i "error" /var/log/messages
    grep -r "TODO" /code	                Recursively search for ‚ÄúTODO‚Äù in a directory	            grep -r "TODO" ~/projects/
    grep -R "main()" --include="*.c"	    Search only in .c files	                                    grep -R "main()" --include="*.c" src/
    grep -v "DEBUG" app.log	                Show lines not containing ‚ÄúDEBUG‚Äù	                        grep -v "DEBUG" app.log
    grep -n "pattern" file.txt	            Show matching lines with line numbers	                    grep -n "database" config.yaml
    grep -c "pattern" file.txt	            Count number of matching lines	                            grep -c "ERROR" app.log
    grep -l "pattern" *.txt	                List filenames that contain matches	                        grep -l "username" *.conf
    `grep -E "WARN|ERROR" app.log`	        Use extended regex to match multiple patterns
    grep -F "literal text" file.txt	        Fixed string match (no regex)	                            grep -F "server started" app.log
    grep -Hn "def " *.py	                Show filename and line number for matches	                grep -Hn "def " *.py
    grep -R "password" /etc	                Search recursively for ‚Äúpassword‚Äù keyword	                grep -R "password" /etc
    `grep -R "pattern" /dir	less`	        Paginate long search results
    zgrep "ERROR" file.gz	                Search compressed .gz files	                                zgrep "ERROR" syslog.1.gz
    grep -R --exclude-dir=".git" "import" .	Exclude directories from search	                            grep -R --exclude-dir=".git" "import" src/
    grep -R --include="*.py" "class " .	    Include only .py files	                                    grep -R --include="*.py" "class " .
    grep -A 2 -B 2 "ERROR" app.log	        Show 2 lines before and after matches	                    grep -A 2 -B 2 "ERROR" app.log
    grep -o "pattern" file	                Print only matched text (not whole line)	                grep -o "aws-[a-z0-9-]*" terraform.tfstate




    Common grep options
    --------------------

    Option	    Meaning
    -------     -------
    -i	        Ignore case
    -r / -R	    Recursive search
    -v	        Invert match
    -n	        Show line numbers
    -l	        Print only matching filenames
    --color	    Highlight matches
    -E	        Use extended regex (like egrep)


 3. Faster or More Advanced Pattern Search Tools
 ================================================

    Tool	                Description	                                    Example
    -----                   ------------                                    --------
    egrep / grep -E	        Supports extended regex.	                    `grep -E "WARN
    fgrep / grep -F	        Fixed-string search (no regex).	                grep -F "Error:" log.txt
    ack	                    Developer-friendly grep, respects .gitignore.	ack "import"
    ag (Silver Searcher)	Very fast recursive search, ignores binaries.	ag "TODO" src/
    ripgrep (rg)	        Fastest modern grep alternative.	            rg "pattern" ./


 4. Combining find + grep
 ==========================

    You can combine them to search within certain files only:

        find . -name "*.py" -exec grep -Hn "def " {} \;


    ‚Üí Find all Python function definitions in current directory.

    Or using xargs for efficiency:

        find . -name "*.log" | xargs grep "ERROR"


 5. Searching by Metadata (mtime, size, etc.)
 =============================================

    Goal	                                        Command
    -----                                           --------
    Files modified in last 7 days	                find /home -mtime -7
    Files modified over 30 days ago	                find /home -mtime +30
    Files accessed in last day	                    find /tmp -atime -1
    Files larger than 1GB	                        find /var -size +1G
    Empty files	                                    find . -empty -type f


 6. Searching in Compressed Files
 =================================

    File Type	                Command	                    Example
    ----------                  --------                    --------
    .gz	                        zgrep "pattern" file.gz	    zgrep "ERROR" syslog.1.gz
    .bz2	                    bzgrep "pattern" file.bz2	
    .xz	                        xzgrep "pattern" file.xz


 7. Searching File Contents Case Studies
 ========================================

    Task	                            Command	                                        Description
    -----                               -------                                         ------------
    Find IP addresses in logs	        grep -Eo "([0-9]{1,3}\.){3}[0-9]{1,3}" *.log	Extract IP patterns.
    Find all TODO comments	            grep -R "TODO" --include="*.py"	
    Find ‚Äúpassword‚Äù keyword in configs	grep -R -i "password" /etc	
    Count number of matching lines	    grep -Rc "Error" .	Recursively count per file.


 8. Performance Tips
 =====================

    Use grep -F for fixed strings ‚Üí much faster.
    Use --include or --exclude to limit file types.
    Pipe through less for large outputs:
    grep -R "pattern" /path | less
    Use rg or ag instead of grep for very large trees.
